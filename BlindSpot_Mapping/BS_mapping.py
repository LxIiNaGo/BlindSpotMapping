#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This experiment was created using PsychoPy3 Experiment Builder (v3.2.3),
    on Oct 07, 2019, at 11:42
If you publish work using Psychopy the most relevant publication is:

    Peirce J, Gray JR, Simpson S, MacAskill M, Höchenberger R, Sogo H, Kastman E, Lindeløv JK. (2019) 
        PsychoPy2: Experiments in behavior made easy Behav Res 51: 195. 
        https://doi.org/10.3758/s13428-018-01193-y

"""
##############################################################################
# About the experiment
# This experiment measures the blind spot.
# The participant will view the screen using the test eye with another eye
# covered. There will be a fixation object on the screen, and the participant
# needs to do tasks while gazing at the fixation object. Their eye movements can
# be monitored by an eye-tracker, but the script can work without that.
# 
# The whole experiment has 3 sections: border points detection, staircase, and validation.
# 1. In the first section, the participant will use a mouse to move a cursor horizontally, 
#    vertically and horizontally again, across the blind spot, during which the cursor should
#    perceptually disappear and reappears at blind spot borders. The participant reports when
#    the cursor disappeared and reappeared by clicking the mouse.
#    The participant needs to do this several rounds (forth and back), and the experimenter 
#    controls the progress by pressing "Space".
#
# 2. In the second section, a staircase procedure is performed to estimate the perceptual
#    threshold of not seeing the border points. This section will be fully controlled by
#    the participant. In a single trial, the participant needs to press "Space" when
#    the participant is ready to do the task. Then the participant will be presented
#    with a target object that is the same as the cursor used in the first section.
#    This object will be displayed on the screen for a short time, and then the participant
#    will need to report whether they saw the target object or not by pressing "left" or
#    "right" keys for "no" or "yes". This single trial will happen many times.

# 3. The third section has two options of procedure and the experimenter should decide
#    before the experiment which procedure is to be done.
#    One procedure is a "Scaling" validation procedure, and another one is a "Heat_Map"
#    procedure to map visual sensitivity. They are all fully controlled by the participant.
#    These two procedure also have many trials to complete. And each single trial are
#    structured in the same way as the second section (i.e., participant pressing "Space"
#    to trigger the stimulus --> stimulus being displayed --> stimulus disappear -->
#    participant reporting whether or not saw the stimulus), but the stimuli used there
#    are different.
#    In the validation procedure, ellipses in different sizes will be the stimuli to be
#    displayed at the estimated blind spot location. The sizes of the ellipses will be
#    determined by different scaling coefficients multiplied by the estimated blind spot
#    size (width and height).
#    In the visual sensitivity mapping procedure, a rectangular field fully covering the
#    estimated blind spot will be evenly grided into many cells. These cells will be the
#    stimuli, and in each trial, one cell will be presented.
#
# The whole experiment is controlled by the keyboard. "Esc" to quit; "Space" to skip/go
# to the next/triger the stimulus; "E" to recalibrate the eye-tracker, "D" to turn on/off
# data displaying during experiment; "left"/"right" for "No"/"Yes".
##############################################################################

##############################################################################
# About the code
# The code is initially generated by Psychopy Builder, so it is structured as
# "import modules" --> "experiment settings" --> "defining functions" --> "monitor and 
# displaying settings" --> "initialize components for each routine" --> "prepare and
# start experiment sections" --> "save data and end"

# The code is not perfect and you may need to modify it to get it work.
# Some tips:
#
# 1. It supports only Eyelink at present, but Psychopy has an API for more eye-trackers,
#    so you need to write eye-tracker codes by yourself for other devices.
#
# 2. If you are using Psychopy 3.2.3/4 version, there is a fatal bug within Psychopy
#    itself, so eye-tracker codes do not work.
#    You should amend a Psychopy file to get the code work. The path is:
#
#    "psychopy\psychopy\iohub\devices\eyetracker\hw\sr_research\eyelink\eyetracker.py"
#
#    Edit this eyetracker.py file and remove lines 400 and 401 like:
#        if starting_state != EyeTrackerConstants.DEFAULT_SETUP_PROCEDURE:
#           printExceptionDetailsToStdErr()
#
#    If this still do not work, try to use the lower package “Pylink”, which is developed
#    by SR Research. It is included in a standalone psychopy. If you do not have it you
#    should download from SR Research website but not from PyPI. There is another “Pylink”
#    on PyPI, which is not the one you need. This is why a standalone psychopy is recommended.
#
#    Please look through Psychopy forum for more info.
#
# 3. The appearance of text visual stimuli may vary among screens. e.g., the size and
#    position. Or they may not work. In these cases please edit the corresponding
#    stimuli-creating functions, including "create_text" and "create_info".
#
# 4. Flickering rate (Hz) is in fact dependent on framerate, so the actual 
#    flickering rate depends on the monitor and graphic card. Please test before
#    you determine flickering rate and the time duration of displaying target objects for
#    the second and third sections.
#
# 5. If you print raw data on screen during the experiment (press 'd' to switch), 
#    the actual framerate will be lowered.
#
# 6. If you run "Medium" or "High" mode on participants, during section 1, some participants
#    may report that the cursor is always visible along some paths. This can be due to 
#    individual differences in BS location and size. If this happened, you might need to 
#    determine HT and/or VT paths manually by specify 'Horizontal_Trials' and/or 
#   'Vertical_Trials'.
#
# 7. You need to write codes for data analysis by yourself.
#
# 8. Libraries webcolors and sklearn are not part of the standalone Psychopy. You need
#    to install these libraries for Psychopy's Python.
###################################################################################


###################################################################################
# Import modules

from __future__ import absolute_import, division
import os  # handy system and path functions
import sys  # to get file system encoding
import json
from psychopy import locale_setup
from psychopy import prefs
from psychopy import sound, gui, visual, core, data, event, logging, clock
import math
import numpy as np
from numpy import (sin, cos, tan, log, log10, pi, average,
                   sqrt, std, deg2rad, rad2deg, linspace, asarray)
from numpy.random import random, randint, normal, shuffle
import pandas as pd
from sklearn.cluster import KMeans
from webcolors import name_to_rgb
from psychopy.hardware import keyboard
from psychopy.misc import fromFile

###################################################################################


###################################################################################
# Preparation

# Ensure that relative paths start from the same directory as this script
_thisDir = os.path.dirname(os.path.abspath(__file__))
os.chdir(_thisDir)

expName = 'BS_mapping'


# Exp settings, can be specified before experiment
with open(_thisDir + "/expconfig.json", "r") as f:
    expInfo = json.load(f)

# Dialog box "BS_mapping"
expdlg = gui.DlgFromDict(dictionary=expInfo, sortKeys=False, title=expName)
if expdlg.OK == False: # "dlg.OK" returns boolean. "dlg.OK" == bool(dlg)
    core.quit()  # user pressed cancel
expInfo['Date'] = data.getDateStr()  # add a simple timestamp
expInfo['ExpName'] = expName

# Dialog box "Staircase settings"
if expInfo['Staircase'] == 'True':
    with open(_thisDir + "/staircaseconfig.json", "r") as f:
        staircaseInfo = json.load(f)
    staircasedlg = gui.DlgFromDict(dictionary = staircaseInfo, sortKeys = False, title = 'Staircase settings')
    if staircasedlg.OK == False:
        core.quit()
elif expInfo['Staircase'] == 'False':
    staircaseInfo = {}

# Dialog box "Validation settings"
if expInfo['Validation'] == 'No':
    validationInfo = {}
else:
    with open(_thisDir + "/validationconfig.json", "r") as f:
        validationInfo = json.load(f)[expInfo['Validation']]
    validationdlg = gui.DlgFromDict(dictionary = validationInfo, sortKeys = False, title = 'Validation settings')
    if validationdlg.OK == False:
        core.quit()


# Dialog box "Eyetracker settings"
# This code block may work only for Eyelink
if expInfo['Eye_Tracker'] == 'True':
    with open(_thisDir + "/eyetrackingconfig.json", "r") as f:
        eyetrackingInfo = json.load(f) # 9-point calibration is good enough
    eyetrackingdlg = gui.DlgFromDict(dictionary = eyetrackingInfo, sortKeys = False, title = 'Eyetracker settings')
    # adjust iohub_config if you use other eye tracker models other than EYELINK 1000 DESKTOP
    iohub_config = {'eyetracker.hw.sr_research.eyelink.EyeTracker':
                       {'name': 'tracker',
                        'model_name': 'EYELINK 1000 DESKTOP',
                        'runtime_settings': {'sampling_rate': 1500,
                                             'track_eyes': expInfo['Test_Eye']}
                        }
                    }
    if eyetrackingdlg.OK == False:
        core.quit()
elif expInfo['Eye_Tracker'] == 'False':
    eyetrackingInfo = {}

# Use eval() to transform str to other types like list and tuple.
for key in staircaseInfo:
    staircaseInfo[key] = eval(staircaseInfo[key])

for key in validationInfo:
    validationInfo[key] = eval(validationInfo[key])

for key in eyetrackingInfo:
    try:
        eyetrackingInfo[key] = eval(eyetrackingInfo[key])
    except: pass

# Some exp info is to be used, so transform str to other types.
for key in ['Fix_Pos(pix)', 'Show_Raw_Data', 'Flickering(Hz)', 
            'Cursor_Size(pix)', 'Fix_Size(pix)', 'Distance(cm)', 'Staircase', 'Eye_Tracker',
            'Monitor_Size(pix)', 'Monitor_Size(cm)', 
            'BG_Color', 'Cursor_Color', 'Fix_Color']:
    try:
        expInfo[key] = eval(expInfo[key])
    except Exception:
        expInfo[key] = tuple(name_to_rgb(expInfo[key]))
expInfo['Fix_Pos(pix)'] = list(expInfo['Fix_Pos(pix)'])

# Set x pos of fixation according to expInfo['Test_Eye'] and expInfo['Fix_Pos(pix)']
# Here 'Test_Eye' is for double check, so the fixation object always left to the center if
# test eye is right, or right ti the center if test eye is left.
# For example, if you want to test right eye, you need to specify Test_Eye = 'RIGHT',
# and Fix_Pos = (n, m) where n < 0 and m = any number.
# but if you input Fix_Pos = (n, m) where n > 0 and m = any, it is also fine, because
# the codes change all Fix_Pos values to (a * |n|, m) where a = -1 if Test_Eye = 'RIGHT',
# or a = 1 if Test_Eye = 'LEFT'.
if expInfo['Test_Eye'] == 'RIGHT':
    a = -1
elif expInfo['Test_Eye'] == 'LEFT':
    a = 1
else:
    a = 1
expInfo['Fix_Pos(pix)'][0] = a * abs(expInfo['Fix_Pos(pix)'][0])
monitor_size = expInfo['Monitor_Size(pix)']
monitor_size_cm = expInfo['Monitor_Size(cm)']

###################################################################################


###################################################################################
# Functions

# distance() returns the distance between 2 dots
def distance(a, b):
    return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)

# deg_to_pix() converts deg to pix
def deg_to_pix(deg, length, res, distance):
    # length in cm, res in pix, distance in cm
    # deg_per_pix = math.degrees(math.atan2(0.5*length, distance)) / (0.5*res)
    return deg * 0.5 * res / math.degrees(math.atan2(0.5*length, distance))

# good_fix() returns whether or not eye movement is larger than tolerance
def good_fix(fix, gaze, tolerance):
    # all in pix
    if distance(fix, gaze) <= tolerance:
        return True
    else:
        return False

# create_mndnp() creates a moving dot (replaces the cursor), a text (indicates the dot position), and a mouse.
def create_mndnp(names = [], monitor_size = monitor_size):
    mouse = event.Mouse(visible = False)
    mouse.name = names[0]
    dot = visual.GratingStim(win = win, name = names[1], tex= None, units = 'pix', 
                             mask="circle", pos=(0, 0), size=(expInfo['Cursor_Size(pix)'], expInfo['Cursor_Size(pix)']), colorSpace = 'rgb255', 
                             color=expInfo['Cursor_Color'], autoLog=False)
    dot_pos = visual.TextStim(win = win, name = names[2], pos=(-0.9, -0.9), 
                              units = 'norm', alignHoriz='center', alignVert = 'center', height=0.06, 
                              text='', autoLog=False)
    return mouse, dot, dot_pos

# create_fixation() creates a fixation object
def create_fixation(name = ''):
    fixation = visual.RadialStim(win = win, name=name, units='pix', pos=expInfo['Fix_Pos(pix)'],
                                size=expInfo['Fix_Size(pix)'], radialCycles=0.6, angularCycles=0, radialPhase=-0.4, angularPhase=0,
                                ori=0, texRes=64, angularRes=100, 
                                color=expInfo['Fix_Color'], colorSpace='rgb255',
                                contrast=1.0, opacity=1.0)
    return fixation

# create_text() creates a text centered at (0, 0)
def create_text(name, text, monitor_size = monitor_size):
    textstim = visual.TextStim(win=win, name=name, text=text, font='Arial',
                               units='norm', pos=(0,0), height=0.08,
                               wrapWidth=None, ori=0, color= expInfo['Cursor_Color'], 
                               colorSpace='rgb255', opacity=1, languageStyle='LTR')
    return textstim

# create_info() creates a text showing some exp info on the screen during experiment.
def create_info(name = '', monitor_size = monitor_size):
    information = visual.TextStim(win = win, name = name, pos=(-1, 1), 
                           units = 'norm', alignHoriz='left', alignVert = 'top',
                           wrapWidth=0.5,
                           height=0.04, text='', autoLog=False)
    return information

# non_rep_append()
# The list will not append the new element if the new one is the same as the final element of the list.
def non_rep_append(l, ele):
    if l:
        if l[-1] == ele:
            pass
        else:
            l.append(ele)
    else:
        l.append(ele)
    return l

# click_recorder() recordes successful clicks.
def click_recorder(mouse, mouse_x, mouse_y, dots, eye_tracker = False):
    beep = sound.Sound('300', volume = 0.1, secs=0.3, stereo=True, hamming=False, name='beep')
    mouse0, mouse1, mouse2 = mouse.getPressed()
    record = True
    if eye_tracker:
        record = good # good is a global var, indicates whether or not the participant is gazing at the fixation object.
    if mouse0 and record:
        non_rep_append(dots, (mouse_x, mouse_y))
        beep.play(when = win)
        mouse.clickReset()
        return True
    else:
        return False

# Given a full set of vertices, dots_estimation() clusters them into 2 subgroups using KMeans, 
# and returns the average dot for each subgroup.
# It should be called by the end of HT/VT/HD routines
def dots_estimation(dots, axis = 0):
    # axis should be set 0 for HT and HD dots, 1 for VT dots.
    def washing(data, axis):
        # cluster dots into 2 sub_groups
        kmeans = KMeans(2).fit(data)
        labels = kmeans.labels_
        sub1 = [data[x] for x in range(len(labels)) if labels[x] == 0]
        sub2 = [data[x] for x in range(len(labels)) if labels[x] == 1]
        # exclude outliers (1.5 IQR)
        sub1_q3, sub1_q1 = np.percentile(sub1, [75, 25], axis = 0)
        sub1_iqr = (sub1_q3 - sub1_q1)[axis]
        sub1_interval = [sub1_q1[axis] - 1.5 * sub1_iqr, sub1_q3[axis] + 1.5 * sub1_iqr]
        sub2_q3, sub2_q1 = np.percentile(sub2, [75, 25], axis = 0)
        sub2_iqr = (sub2_q3 - sub2_q1)[axis]
        sub2_interval = [sub2_q1[axis] - 1.5 * sub2_iqr, sub2_q3[axis] + 1.5 * sub2_iqr]
        new_sub1 = [dot for dot in sub1 if abs(dot[axis] - sub1_interval[0]) + abs(dot[axis] - sub1_interval[1]) <= abs(sub1_interval[0] - sub1_interval[1]) ]
        new_sub2 = [dot for dot in sub2 if abs(dot[axis] - sub2_interval[0]) + abs(dot[axis] - sub2_interval[1]) <= abs(sub2_interval[0] - sub2_interval[1]) ]
        return new_sub1 + new_sub2

    def km_centers(km_model, axis):
        dot1, dot2 = km_model.cluster_centers_
        if dot1[axis] <= dot2[axis]:
            pass
        else:
            dot1, dot2 = dot2, dot1
        return tuple(dot1), tuple(dot2)

    # First, group all dots based on paths
    # The logic is that, if HT/VT has multi trial paths, the dots from the same path share the same y/x coordinate, 
    # so that dots from different trial paths can be divided accordingly.
    group_idx = []
    for x in dots:
        group_idx = non_rep_append(group_idx, x[axis - 1])
    groups = []
    for idx in group_idx:
        group = []
        group = [x for x in dots if x[axis - 1] == idx]
        groups.append(group)
    
    # Calculate 2 average dots for each subgroup and ingeterate all dots into one list
    c_dots = []
    for subset in groups:
        if len(subset) == 1:
            c_dots.append(subset[0])
        else:
            # data washing, filter out outliers
            subset = washing(subset, axis)
            kmeans = KMeans(2).fit(subset)
            dot1, dot2 = km_centers(kmeans, axis)
            c_dots.append(dot1)
            c_dots.append(dot2)
    return c_dots

# order_dots() orders dots to plot BS
def order_dots(dots):
    # compute the highest dot of these dots
    dots = np.array(dots)
    top = [dot for dot in dots if dot[1] == dots.max(axis = 0)[1]][0]
    # calculate degree to top dot for each dot in dots
    def deg(dot):
        arctan = math.atan2(*(dot - top)[::-1])
        return math.degrees(arctan) % 360
    # sort dots by degree
    ordered_dots = sorted(dots, key=deg)
    return [tuple(dot) for dot in ordered_dots]

# sum_bad_fixation() returns the number of bad fixation(s) during a specific time duration
# It is basically a sum() function
def sum_bad_fixation(tracking_dict, onset_frameN, offset_frameN, time_back = 0.03, time_forward = 0, framedur = 1/60):
    try:
    # framedur is a global var
        frames_back = round(time_back / framedur) # convert time_back(in second) to frame_back(in frame count)
        frames_forward = round(time_forward / framedur) # convert time_forward(in second) to frame_forward(in frame count)
        start_idx = int(tracking_dict['frameN'].index(onset_frameN) - frames_back)
        end_idx = int(tracking_dict['frameN'].index(offset_frameN) + frames_forward)
        sumation = end_idx - start_idx - sum(tracking_dict['good_fixation'][start_idx:end_idx])
    except Exception as e:
        print(e)
        sumation = 1
    return sumation
###################################################################################


###################################################################################
# Start Code - component code to be run before the window creation

# Eye tracker (if set True)
if expInfo['Eye_Tracker']:
    from psychopy.iohub import launchHubServer
    io = launchHubServer(**iohub_config)
    # Get the eye tracker device.
    tracker = io.devices.tracker
    tracker.runSetupProcedure()
    tracker.setRecordingState(True)
    tolerance = deg_to_pix(eyetrackingInfo['Tolerance(deg)'], monitor_size_cm[1], monitor_size[1], expInfo['Distance(cm)'])

# Setup the Window
win = visual.Window(
    size=monitor_size, fullscr=False, screen=0, 
    winType='pyglet', allowGUI=False, allowStencil=False,
    monitor=expInfo['Monitor_Name'], colorSpace='rgb255', color=expInfo['BG_Color'], 
    blendMode='avg', useFBO=True, 
    units='pix')
frameTolerance = 0.001  # how close to onset before 'same' frame

# Store frame rate of monitor if we can measure it
expInfo['FrameRate'] = round(win.getActualFrameRate())
if expInfo['FrameRate'] != None:
    frameDur = 1.0 / expInfo['FrameRate']
else:
    frameDur = 1.0 / 60.0  # could not measure, so guess
if expInfo['Flickering(Hz)']:
    flickering_frameRate = round(1 / (expInfo['Flickering(Hz)'] * frameDur)) # flickering according to frame number

# Create a default keyboard (e.g. to check for escape)
defaultKeyboard = keyboard.Keyboard()
endExpNow = False  # flag for 'escape' or other condition => quit the exp
###################################################################################


###################################################################################

# Initialize components for all routines

###################################################################################

# Initialize components for routine "Exp_start"
Exp_startClock = core.Clock()
exp_start = create_text(name = 'exp_start', 
                        text= 'You are going to map your ' + 
                        expInfo['Test_Eye'] + 
                        ' Blind Spot.\n\n\n*Please press "space" key to begin...'
                       )
exp_start_end = keyboard.Keyboard()
exp_start_mouse, exp_start_dot, exp_start_dot_pos = create_mndnp(names = ['exp_start_mouse', 'exp_start_dot', 'exp_start_dot_pos'])
exp_start_info = create_info(name = 'exp_start_info')

###################################################################################

###################################################################################

# Initialize components for Routine "Fixation"
FixationClock = core.Clock()
fixation_instruction = create_text(name='fixation_instruction',
                             text=('Please gaze at the fixation object to do tasks.\nThen press "space" key, '
                                   'there will be a beep indicating the start of the experiment.\n\n\n\n\n\n\n'
                                   '*Please press "space" key to continue...')
                             )
fixation_fixation = create_fixation(name = 'fixation_fixation')
fixation_mouse, fixation_dot, fixation_dot_pos = create_mndnp(names = ['fixation_mouse', 'fixation_dot', 'fixation_dot_pos'])
fixation_end = keyboard.Keyboard()
fixation_info = create_info(name = 'fixation_info')

###################################################################################

###################################################################################

# Initialize components for Routine "HT_start"
HT_startClock = core.Clock()
ht_start_beep = sound.Sound('1000', secs=1.0, stereo=True, hamming=False, volume = 1, name='ht_start_beep')
ht_start_fixation = create_fixation(name='ht_start_fixation')
ht_start_mouse, ht_start_dot, ht_start_dot_pos = create_mndnp(names = ['ht_start_mouse', 'ht_start_dot', 'ht_start_dot_pos'])
ht_start_info = create_info(name = 'ht_start_info')

###################################################################################

###################################################################################

# Initialize components for Routine "HT_trials"
HT_trialsClock = core.Clock()
ht_trials_fixation = create_fixation(name='ht_trials_fixation')
ht_trials_mouse, ht_trials_dot, ht_trials_dot_pos = create_mndnp(names = ['ht_trials_mouse', 'ht_trials_dot', 'ht_trials_dot_pos'])
ht_trials_end = keyboard.Keyboard()
ht_trials_info = create_info(name = 'ht_trials_info')

###################################################################################

###################################################################################

# Initialize components for Routine "VT_start"
VT_startClock = core.Clock()
vt_start_beep = sound.Sound('1000', secs=1.0, stereo=True, hamming=False, volume = 1, name='vt_start_beep')
vt_start_fixation = create_fixation(name='vt_start_fixation')
vt_start_mouse, vt_start_dot, vt_start_dot_pos = create_mndnp(names = ['vt_start_mouse', 'vt_start_dot', 'vt_start_dot_pos'])
vt_start_info = create_info(name = 'vt_start_info')

###################################################################################

###################################################################################

# Initialize components for Routine "VT_trials"
VT_trialsClock = core.Clock()
vt_trials_fixation = create_fixation(name='vt_trials_fixation')
vt_trials_mouse, vt_trials_dot, vt_trials_dot_pos = create_mndnp(names = ['vt_trials_mouse', 'vt_trials_dot', 'vt_trials_dot_pos'])
vt_trials_end = keyboard.Keyboard()
vt_trials_info = create_info(name = 'vt_trials_info')

###################################################################################

###################################################################################

# Initialize components for Routine "HD_start"
HD_startClock = core.Clock()
hd_start_beep = sound.Sound('1000', secs=1.0, stereo=True, hamming=False, volume = 1, name='hd_start_beep')
hd_start_fixation = create_fixation(name='hd_start_fixation')
hd_start_mouse, hd_start_dot, hd_start_dot_pos = create_mndnp(names = ['hd_start_mouse', 'hd_start_dot', 'hd_start_dot_pos'])
hd_start_info = create_info(name = 'hd_start_info')

###################################################################################

###################################################################################

# Initialize components for Routine "HD_trials"
HD_trialsClock = core.Clock()
hd_trials_fixation = create_fixation(name='hd_trials_fixation')
hd_trials_mouse, hd_trials_dot, hd_trials_dot_pos = create_mndnp(names = ['hd_trials_mouse', 'hd_trials_dot', 'hd_trials_dot_pos'])
hd_trials_end = keyboard.Keyboard()
hd_trials_info = create_info(name = 'hd_trials_info')

###################################################################################

###################################################################################

# Initialize components for Routine "Staircase"
StaircaseClock = core.Clock()
staircase_fixation = create_fixation(name = 'staircase_fixation')
staircase_start_beep = sound.Sound('1000', secs=1.0, stereo=True, hamming=False, volume = 1, name='staircase_start_beep')
staircase_info = create_info(name = 'staircase_info')
staircase_end = keyboard.Keyboard()
staircase_target = visual.GratingStim(win = win, name = 'staircase_target', 
                                      tex= None, units = 'pix', mask="circle", 
                                      pos=(0, 0), size=(expInfo['Cursor_Size(pix)'], expInfo['Cursor_Size(pix)']),
                                      colorSpace = 'rgb255', 
                                      color=expInfo['Cursor_Color'], 
                                      autoLog=False, opacity = 0)
staircase_doUCit = sound.Sound(value = 'doUCit.wav', secs = 1.05, stereo = True, hamming=False, volume = 1, 
                               name = 'staircase_doUCit')

###################################################################################

###################################################################################

# Initialize components for Routine "Validation"
ValidationClock = core.Clock()
validation_fixation = create_fixation(name = 'validation_fixation')
validation_info = create_info(name = 'validation_info')
validation_end = keyboard.Keyboard()
# Create texture
s = int(512/expInfo['Cursor_Size(pix)'])
texture = np.random.randint(2, size = (s, s)) * 2.0 - 1
validation_start_beep = sound.Sound('1000', secs=1.0, stereo=True, hamming=False, volume = 1, name='validation_start_beep')
if expInfo['Validation'] == 'Scaling':
    validation_target = visual.GratingStim(win = win, name = 'validation_target', 
                                           tex= texture, units = 'pix', mask="circle", 
                                           pos=(0, 0), size=(512, 512), colorSpace = 'rgb255', 
                                           color=expInfo['Cursor_Color'], autoLog=False, interpolate = False)
elif expInfo['Validation'] == 'Heat_Map':
    validation_target = visual.Rect(win=win, name='validation_target',units='pix', 
                                    width=0, height=0, ori=0, pos=(0, 0), 
                                    lineWidth=0, lineColor=expInfo['Cursor_Color'], 
                                    lineColorSpace='rgb255', fillColor=expInfo['Cursor_Color'], 
                                    fillColorSpace='rgb255', opacity=1, depth=0.0, interpolate=True)
else: validation_target = None
validation_doUCit = sound.Sound(value = 'doUCit.wav', secs = 1.05, stereo = True, hamming=False, volume = 1,
                               name = 'validation_doUCit')

###################################################################################

###################################################################################

# Initialize components for Routine "Test_complete"
Test_completeClock = core.Clock()
test_complete = create_text(name='test_complete',
                            text=('Congratulations!\n\nYou have completed all sections.\n\n\n\n\n\n\n'
                                  '*Please press "space" key to see the result...')
                            )
test_complete_fixation = create_fixation(name='test_complete_fixation')
test_complete_mouse, test_complete_dot, test_complete_dot_pos = create_mndnp(names = ['test_complete_mouse', 'test_complete_dot', 'test_complete_dot_pos'])
test_complete_end = keyboard.Keyboard()
test_complete_info = create_info(name = 'test_complete_info')

###################################################################################

###################################################################################

# Initialize components for Routine "Mapping_result"
Mapping_resultClock = core.Clock()
mapping_result = create_text(name='mapping_result',
                             text='\n\n\n\n\n\n\n\n\n\n\n\n\n\n*Please press "space" key to end the experiment...'
                             )
test_fixation = create_fixation(name = 'test_fixation')
mapping_result_mouse, mapping_result_dot, mapping_result_dot_pos = create_mndnp(names = ['mapping_result_mouse', 'mapping_result_dot', 'mapping_result_dot_pos'])
mapping_result_end = keyboard.Keyboard()
mapping_result_info = create_info(name = 'mapping_result_info')
mapping_result_bs = visual.ShapeStim(win = win, units='pix', lineWidth=1, lineColor='black', lineColorSpace='rgb255', 
                                     fillColor='black', fillColorSpace='rgb255', vertices=[(-0.5, 0), (0, 0.5), (0.5, 0)], 
                                     closeShape=True, interpolate=True, name='mapping_result_bs')

###################################################################################


###################################################################################

# Create some handy timers
globalClock = core.Clock()  # to track the time since experiment started
routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 

# ht_clicks stores click pos in HT
ht_clicks = []

# vt_clicks stores click pos in VT
vt_clicks = []

# ht_dots stores HT pos processed by dots_estimation
ht_dots = []

# vt_dots stores VT pos processed by dots_estimation
vt_dots = []

###################################################################################

# Data saving
# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc
filename = _thisDir + os.sep + u'data/%s_%s_%s_%s' % (expInfo['Participant'], expInfo['Session'], expName, expInfo['Date'])

# An ExperimentHandler isn't essential but helps with data saving
thisExp = data.ExperimentHandler(name=expName, version='',
    extraInfo=expInfo, runtimeInfo=None,
    savePickle=True, saveWideText=True,
    dataFileName=filename)
# save a log file for detail verbose info
# logFile = logging.LogFile(filename+'.log', level=logging.EXP)
logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file

###################################################################################


#######################################################################################

# ------Prepare to start Routine "Exp_start"-------

# reset timers
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Exp_startClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
continueRoutine = True

Exp_start_autodraw = [exp_start, exp_start_dot, exp_start_info, exp_start_dot_pos, ]

# -------Run Routine "Exp_start"-------
keyboard_start = False
while continueRoutine:
    tThisFlip = win.getFutureFlipTime(clock=Exp_startClock)
    # update/draw components on each frame
    # *exp_start*, *exp_start_mouse* and *exp_start_dot* updates
    if tThisFlip >= 0.0-frameTolerance:
        exp_start.setAutoDraw(True)
        mouse_x, mouse_y = exp_start_mouse.getPos()
        exp_start_dot.setPos(newPos = [mouse_x, mouse_y])
        exp_start_dot.setAutoDraw(True)

    # *exp_start_info*, and *exp_start_dot_pos* updates
    if tThisFlip >= 0.0-frameTolerance and expInfo['Show_Raw_Data']:
        exp_start_info.text = (f"Frame rate: {win.getActualFrameRate()}\nMode: {expInfo['Mode']}, Trial: Not Start\n"
                               f"HT_points:\n{ht_dots}\nVT_points:\n{vt_dots}\n\nHT_clicks: \n{ht_clicks}\nVT_clicks: \n"
                               f"{vt_clicks}")
        exp_start_info.setAutoDraw(True)
        exp_start_dot_pos.text = f"X: {mouse_x}\nY: {mouse_y}"
        exp_start_dot_pos.setAutoDraw(True)
    
    # *exp_start_end* updates
    if tThisFlip >= 0.0-frameTolerance and not keyboard_start:
        keyboard_start = True
        win.callOnFlip(exp_start_end.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if keyboard_start == True:
        theseKeys = exp_start_end.getKeys(keyList=['space', 'd'], waitRelease=False)
        if len(theseKeys):
            theseKeys = theseKeys[0]  # at least one key was pressed
            if theseKeys == 'space':
                continueRoutine = False
            elif theseKeys == 'd':
                expInfo['Show_Raw_Data'] = not expInfo['Show_Raw_Data']
                exp_start_dot_pos.setAutoDraw(expInfo['Show_Raw_Data'])
                exp_start_info.setAutoDraw(expInfo['Show_Raw_Data'])
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    # refresh the screen
    elif continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Exp_start"-------
for thisComponent in Exp_start_autodraw:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# the Routine "Exp_start" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

###################################################################################


###################################################################################

# ------Prepare to start Routine "Fixation"-------

# reset timers
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
FixationClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
continueRoutine = True
frameN = -1

Fixation_autodraw = [fixation_instruction, fixation_fixation, fixation_dot, fixation_info, fixation_dot_pos]

# -------Run Routine "Fixation"-------
keyboard_start = False
while continueRoutine:
    # get current time
    t = FixationClock.getTime()
    t_global = globalClock.getTime()
    frameN += 1
    tThisFlip = win.getFutureFlipTime(clock=FixationClock)

    # update/draw components on each frame
    
    # *fixation_instruction*, *fixation_fixation*, *fixation_mouse* and *fixation_dot* updates
    if tThisFlip >= 0.0-frameTolerance:
        fixation_instruction.setAutoDraw(True)
        if expInfo['Eye_Tracker']:
            gaze = tracker.getPosition()
            if gaze is None:
                gaze = (99999, 99999)
            else: pass
            good = good_fix(expInfo['Fix_Pos(pix)'], gaze, tolerance)
            if not good:
                fixation_fixation.color = tuple(name_to_rgb('red'))
            else:
                fixation_fixation.color = expInfo['Fix_Color']

        fixation_fixation.setAutoDraw(True)
        mouse_x, mouse_y = fixation_mouse.getPos()
        fixation_dot.setPos(newPos = [mouse_x, mouse_y])
        fixation_dot.setAutoDraw(True)

    # *fixation_info*, and *fixation_dot_pos* updates
    if tThisFlip >= 0.0-frameTolerance and expInfo['Show_Raw_Data']:
        fixation_info.text = (f"Mode: {expInfo['Mode']}, Trial: Not Start\nHT_points:\n{ht_dots}\nVT_points:\n"
                              f"{vt_dots}\n\nHT_clicks: \n{ht_clicks}\nVT_clicks: \n{vt_clicks}")
        fixation_info.setAutoDraw(True)
        if expInfo['Eye_Tracker']:
            fixation_dot_pos.text = f"X: {mouse_x}, gaze_X: {int(gaze[0])}\nY: {mouse_y}, gaze_Y: {int(gaze[1])}"
        else:
            fixation_dot_pos.text = f"X: {mouse_x}\nY: {mouse_y}"
        fixation_dot_pos.setAutoDraw(True)

    # *fixation_end* updates
    if tThisFlip >= 0.0-frameTolerance and not keyboard_start:
        keyboard_start = True
        win.callOnFlip(fixation_end.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if keyboard_start:
        theseKeys = fixation_end.getKeys(keyList=['space', 'e', 'd'], waitRelease=False)
        if len(theseKeys):
            theseKeys = theseKeys[0]  # at least one key was pressed
            if theseKeys == 'e' and expInfo['Eye_Tracker']:
                win.winHandle.minimize()
                win.winHandle.set_fullscreen(False)
                tracker.setRecordingState(False)
                tracker.runSetupProcedure()
                tracker.setRecordingState(True)
                win.winHandle.maximize()
                win.winHandle.set_fullscreen(True)
                win.winHandle.activate()
            elif theseKeys == 'd':
                expInfo['Show_Raw_Data'] = not expInfo['Show_Raw_Data']
                fixation_dot_pos.setAutoDraw(expInfo['Show_Raw_Data'])
                fixation_info.setAutoDraw(expInfo['Show_Raw_Data'])
            elif theseKeys == 'space':
                # a response ends the routine
                continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    elif continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Fixation"-------
for thisComponent in Fixation_autodraw:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# the Routine "Fixation" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

###################################################################################


###################################################################################

# ------Prepare to start Routine "HT_start"-------

# Now prepare the experiment phase 1/3 of the "Border points detection section".

# Reasonable values of BS position (in pix) and height
bs_c_y = 0 # blind spot center vertical (y) coordinate
# blind spot height (pix), here 7.5 degrees
bs_h = 7.5 * int(deg_to_pix(1, monitor_size_cm[1], monitor_size[1], expInfo['Distance(cm)']))

# Section 1 itself has 3 phases, horizontal test 1st (HT), vertical test 1st (VT) and
# horizontal test 2nd (HD).
# Note that expInfo['Horizontal_Trials'] and expInfo['Vertical_Trials'] predetermine
# HT and VT. HD cannot be determined by you.

# Now set HT paths and VT paths

# Explain the rationale based on "Low" mode.
# HT, VT, and HD make up a 3-step border points detection procedure.
# The primary assumption of a 3-step procedure is that, the BS can be simplified as an
# up right ellipse. 
# In HT, the cursor can be moved horizontally, and will disappear or reappear at 2 BS
# borders.
# The VT path is determined by the midpoint (mid_1) of these 2 dots.
# In VT, the cursor can be moved vertically. Similarly, there are also 2 dots estimated
# by VT, and the midpoint (mid_2) of them determines HD path.
# HD again estimates 2 dots and their midpoint (mid_3).
# So the blind spot center is mid_3, the blind spot height is the seperation of the 2
# dots in VT, while the width is the seperation of the 2 dots in HD.

# Default HT settings according to mode.

# 'Low' mode: HT and VT each has 1 path. HT path is determined here.
# VT path will be based on HT dots.
# HD has only 1 path, and will be dependent on VT results.
if expInfo['Mode'] == 'Low':
    expInfo['H_Trials'] = [bs_c_y] # short var name to save typing
    expInfo['V_Trials'] = [] # short var name to save typing

# 'Medium' mode: HT and VT each has 3 paths. HD has only 1.
elif expInfo['Mode'] == 'Medium':
    expInfo['H_Trials'] = [bs_c_y, bs_c_y + bs_h/4,  bs_c_y - bs_h/4]
    expInfo['V_Trials'] = []

# 'High' mode: HT and VT each has 5 paths. HD has only 1.
elif expInfo['Mode'] == 'High':
    expInfo['H_Trials'] = [bs_c_y, bs_c_y + bs_h/6, bs_c_y + bs_h*(2/6), 
                     bs_c_y - bs_h/6, bs_c_y - bs_h*(2/6)]
    expInfo['V_Trials'] = []

# Though not recommend to do so, you can explicitly determine HT and/or VT paths.
# Your paths will overwrite the default settings of mode.
if expInfo['Horizontal_Trials'] == 'Default' and expInfo['Vertical_Trials'] == 'Default':
    pass
elif expInfo['Horizontal_Trials'] != 'Default' and expInfo['Vertical_Trials'] == 'Default':
    expInfo['Mode'] = expInfo['Mode'] + ', ' + 'HT_User'
    expInfo['H_Trials'] = eval(expInfo['Horizontal_Trials'])
elif expInfo['Horizontal_Trials'] == 'Default' and expInfo['Vertical_Trials'] != 'Default':
    expInfo['Mode'] = expInfo['Mode'] + ', ' + 'VT_User'
    expInfo['V_Trials'] = eval(expInfo['Vertical_Trials'])
elif expInfo['Horizontal_Trials'] != 'Default' and expInfo['Vertical_Trials'] != 'Default':
    expInfo['Mode'] = 'User'
    expInfo['V_Trials'] = eval(expInfo['Vertical_Trials'])
    expInfo['H_Trials'] = eval(expInfo['Horizontal_Trials'])
expInfo['HT_N'] = len(expInfo['H_Trials'])

ht_N = expInfo['HT_N'] # save typing

# reset path No.
ht_n = 1
ht_tests = expInfo['H_Trials'] # save typing

routineTimer.add(1.000000)

# update component parameters for each repeat
HT_start_autodraw = [ht_start_fixation, ht_start_dot, ht_start_dot_pos, ht_start_info]

# reset timers
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
HT_startClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip

# initiate Routine
continueRoutine = True

###################################################################################

# -------Run Routine "HT_start"-------
beep_start = False
fixation_start = False
while continueRoutine and routineTimer.getTime() > 0:
    tThisFlip = win.getFutureFlipTime(clock=HT_startClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)

    # update/draw components on each frame
    # start/stop ht_start_beep
    if not beep_start and tThisFlip >= 0.0-frameTolerance:
        ht_start_beep.tStartRefresh = tThisFlipGlobal  # on global time
        ht_start_beep.play(when=win)  # sync with win flip
        beep_start = True
    if beep_start:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > ht_start_beep.tStartRefresh + 1.0-frameTolerance:
            ht_start_beep.stop()
    
    # *ht_start_fixation* updates
    if not fixation_start and tThisFlip >= 0.0-frameTolerance:
        ht_start_fixation.tStartRefresh = tThisFlipGlobal  # on global time
        ht_start_fixation.setAutoDraw(True)
        fixation_start = True
    if fixation_start:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > ht_start_fixation.tStartRefresh + 1-frameTolerance:
            ht_start_fixation.setAutoDraw(False)

    # *ht_start_info* and *ht_start_dot_pos* updates
    if tThisFlip >= 0.0-frameTolerance and expInfo['Show_Raw_Data']:
        ht_start_info.text = (f"Mode: {expInfo['Mode']}, Trial: H{ht_n}/H{ht_N+1}\nHT_points:\n{ht_dots}\nVT_points:\n"
                              f"{vt_dots}\n\nHT_clicks: \n{ht_clicks}\nVT_clicks: \n{vt_clicks}")
        ht_start_info.setAutoDraw(True)
        ht_start_dot_pos.text = f"X: {mouse_x}\nY: {mouse_y}"
        ht_start_dot_pos.setAutoDraw(True)

    # *ht_start_mouse* and *ht_start_dot* updates
    if tThisFlip >= 0.0-frameTolerance:
        mouse_x, mouse_y = ht_start_mouse.getPos()
        ht_start_dot.setPos(newPos = [mouse_x, mouse_y])
        ht_start_dot.setAutoDraw(True)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    elif continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "HT_start"-------
for thisComponent in HT_start_autodraw:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
ht_start_beep.stop()  # ensure sound has stopped at end of routine

###################################################################################


###################################################################################

# ------Prepare to start Routine "HT_trials"-------

# update component parameters for each repeat
# keep track of which components have finished
HT_trials_autodraw = [ht_trials_fixation, ht_trials_dot, 
                       ht_trials_dot_pos, ht_trials_info]
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
HT_trialsClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip

# initiate Routine
continueRoutine = True
frameN = -1
if expInfo['Eye_Tracker']:
    HT_trials_tracking = {'frameN': [], 'routine_time':[], 'global_time':[], 'gaze':[], 'good_fixation':[], 'click': []}

# -------Run Routine "HT_trials"-------
ht_trials_mouse.clickReset()
ht_trials_dot_ocolor_rgb = [float(x) for x in ht_trials_dot.color]
ht_trials_dot_rcolor_rgb = [float(255 - x) for x in ht_trials_dot.color]
keyboard_start = False
while continueRoutine:
    t = HT_trialsClock.getTime()
    t_global = globalClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=HT_trialsClock)
    frameN += 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *ht_trials_fixation*, *ht_trials_mouse* and *ht_trials_dot* updates
    if tThisFlip >= 0.0-frameTolerance:
        if expInfo['Eye_Tracker']:
            gaze = tracker.getPosition()           
            if gaze is None:
                gaze = (99999, 99999)
            else: pass
            good = good_fix(expInfo['Fix_Pos(pix)'], gaze, tolerance)
            if not good:
                ht_trials_fixation.color = tuple(name_to_rgb('red'))
            else:
                ht_trials_fixation.color = expInfo['Fix_Color']
            HT_trials_tracking['frameN'].append(frameN)
            HT_trials_tracking['routine_time'].append(t)
            HT_trials_tracking['global_time'].append(t_global)
            HT_trials_tracking['gaze'].append(gaze)
            HT_trials_tracking['good_fixation'].append(good)
        ht_trials_fixation.setAutoDraw(True)
        
        # Note that the flickering cursor switches its color according to frameN!!
        # so be cautious about actual framerate and the flickering rate you want
        if expInfo['Flickering(Hz)'] and frameN % flickering_frameRate == 0:
            if all(np.array(ht_trials_dot.color) == np.array(ht_trials_dot_ocolor_rgb)):
                ht_trials_dot.color = ht_trials_dot_rcolor_rgb
            elif all(np.array(ht_trials_dot.color) == np.array(ht_trials_dot_rcolor_rgb)):
                ht_trials_dot.color = ht_trials_dot_ocolor_rgb
            else: pass
        else: pass

        mouse_x, mouse_y = ht_trials_mouse.getPos()[0], ht_tests[ht_n - 1]
        ht_trials_dot.setPos(newPos = [mouse_x, mouse_y])
        clickreport = click_recorder(ht_trials_mouse, mouse_x, mouse_y, ht_clicks, eye_tracker = expInfo['Eye_Tracker'])
        if expInfo['Eye_Tracker']:
            HT_trials_tracking['click'].append(clickreport)
        ht_trials_dot.setAutoDraw(True)

    # *ht_trials_info*, and *ht_trials_dot_pos* updates
    if tThisFlip >= 0.0-frameTolerance and expInfo['Show_Raw_Data']:
        ht_trials_info.text = f"Mode: {expInfo['Mode']}, Trial: H{ht_n}/H{ht_N+1}\nHT_points:\n{ht_dots}\nVT_points:\n{vt_dots}\n\nHT_clicks: \n{ht_clicks}\nVT_clicks: \n{vt_clicks}\ntime: \n{t}"
        ht_trials_info.setAutoDraw(True)

        ht_trials_dot_pos.text = f"X: {mouse_x}\nY: {mouse_y}"
        ht_trials_dot_pos.setAutoDraw(True)
    
    # *ht_trials_end* updates
    if not keyboard_start and tThisFlip >= 0.0-frameTolerance:
        # keyboard checking is just starting
        keyboard_start = True
        win.callOnFlip(ht_trials_end.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if keyboard_start:
        theseKeys = ht_trials_end.getKeys(keyList=['space', 'e', 'd'], waitRelease=False)
        if len(theseKeys):
            theseKeys = theseKeys[0]  # at least one key was pressed
            # a response ends the routine
            if theseKeys == 'space':
                if ht_n < ht_N:
                    ht_n += 1
                else:
                    continueRoutine = False
                    ht_dots = dots_estimation(ht_clicks, axis = 0)
            elif theseKeys == 'd':
                expInfo['Show_Raw_Data'] = not expInfo['Show_Raw_Data']
                ht_trials_info.setAutoDraw(expInfo['Show_Raw_Data'])
                ht_trials_dot_pos.setAutoDraw(expInfo['Show_Raw_Data'])
            elif theseKeys == 'e' and expInfo['Eye_Tracker']:
                win.winHandle.minimize()
                win.winHandle.set_fullscreen(False)
                tracker.setRecordingState(False)
                tracker.runSetupProcedure()
                tracker.setRecordingState(True)
                win.winHandle.maximize()
                win.winHandle.set_fullscreen(True)
                win.winHandle.activate()
        else: pass
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break    
    # refresh the screen
    elif continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()
if expInfo['Eye_Tracker']:
    HT_trials_tracking = pd.DataFrame(HT_trials_tracking)
    HT_trials_tracking["Participant"] = expInfo['Participant']
    HT_trials_tracking["Session"] = expInfo['Session']

# -------Ending Routine "HT_trials"-------
for thisComponent in HT_trials_autodraw:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# the Routine "HT_trials" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

###################################################################################


###################################################################################

# ------Prepare to start Routine "VT_start"-------

# Now prepare VT trials.

# VT paths are based on HT results and mode if expInfo['Verticial_Trials'] is set 'Default'.
# Otherwides they are predetermined by you.
if expInfo['Vertical_Trials'] != 'Default':
    pass
else:
    bs_c_x = np.array(ht_dots).mean(axis = 0)[0] # x coordinate of the bs center, inferred based on HT results
    bs_w = np.array(ht_dots).max(axis = 0)[0] - np.array(ht_dots).min(axis = 0)[0] # average bs width according to HT results

    step_size = bs_w / (ht_N + 1)
    # prepare VT paths accordingly
    steps = [n for n in range(int((ht_N - 1)/2 + 1))]
    steps += [n * -1 for n in steps[1:]]
    expInfo['V_Trials'] = [bs_c_x + n * step_size for n in steps]

expInfo['VT_N'] = len(expInfo['V_Trials'])

# reset path No.
vt_n = 1
vt_N = expInfo['VT_N']
vt_tests = expInfo['V_Trials']

routineTimer.add(1.000000)

# update component parameters for each repeat
VT_start_autodraw = [vt_start_fixation, vt_start_dot, vt_start_dot_pos, vt_start_info]

# reset timers
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
VT_startClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip

# initiate Routine
continueRoutine = True

# -------Run Routine "VT_start"-------

beep_start = False
fixation_start = False
while continueRoutine and routineTimer.getTime() > 0:
    tThisFlip = win.getFutureFlipTime(clock=VT_startClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)

    # update/draw components on each frame
    # start/stop vt_start_beep
    if not beep_start and tThisFlip >= 0.0-frameTolerance:
        vt_start_beep.tStartRefresh = tThisFlipGlobal  # on global time
        vt_start_beep.play(when=win)  # sync with win flip
        beep_start = True
    if beep_start:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > vt_start_beep.tStartRefresh + 1.0-frameTolerance:
            vt_start_beep.stop()
    
    # *vt_start_fixation* updates
    if not fixation_start and tThisFlip >= 0.0-frameTolerance:
        vt_start_fixation.tStartRefresh = tThisFlipGlobal  # on global time
        vt_start_fixation.setAutoDraw(True)
        fixation_start = True
    if fixation_start:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > vt_start_fixation.tStartRefresh + 1.0-frameTolerance:
            vt_start_fixation.setAutoDraw(False)

    # *vt_start_info*, and *vt_start_dot_pos* updates
    if tThisFlip >= 0.0-frameTolerance and expInfo['Show_Raw_Data']:
        vt_start_info.text = (f"Mode: {expInfo['Mode']}, Trial: V{vt_n}/V{vt_N}\nHT_points:\n{ht_dots}\nVT_points:\n"
                              f"{vt_dots}\n\nHT_clicks: \n{ht_clicks}\nVT_clicks: \n{vt_clicks}")
        vt_start_info.setAutoDraw(True)

        vt_start_dot_pos.text = f"X: {mouse_x}\nY: {mouse_y}"
        vt_start_dot_pos.setAutoDraw(True)

    # *vt_start_mouse* and *vt_start_dot* updates
    if tThisFlip >= 0.0-frameTolerance:
        mouse_x, mouse_y = vt_start_mouse.getPos()
        vt_start_dot.setPos(newPos = [mouse_x, mouse_y])
        vt_start_dot.setAutoDraw(True)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()

    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    elif continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "VT_start"-------
for thisComponent in VT_start_autodraw:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
vt_start_beep.stop()  # ensure sound has stopped at end of routine

###################################################################################


###################################################################################

# ------Prepare to start Routine "VT_trials"-------

# keep track of which components have finished
VT_trials_autodraw = [vt_trials_fixation, vt_trials_dot, 
                       vt_trials_dot_pos, vt_trials_info]

# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
VT_trialsClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# initiate Routine
continueRoutine = True
if expInfo['Eye_Tracker']:
    VT_trials_tracking = {'frameN': [], 'routine_time':[], 'global_time':[], 'gaze':[], 'good_fixation':[], 'click': []}

# -------Run Routine "VT_trials"-------

vt_trials_mouse.clickReset()
vt_trials_dot_ocolor_rgb = [float(x) for x in vt_trials_dot.color]
vt_trials_dot_rcolor_rgb = [float(255 - x) for x in vt_trials_dot.color]
keyboard_start = False
while continueRoutine:
    # get current time
    t = VT_trialsClock.getTime()
    t_global = globalClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=VT_trialsClock)
    frameN += 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *vt_trials_fixation*, *vt_trials_mouse* and *vt_trials_dot* updates
    if tThisFlip >= 0.0-frameTolerance:
        if expInfo['Eye_Tracker']:
            gaze = tracker.getPosition()
            if gaze is None:
                gaze = (99999, 99999)
            else: pass
            good = good_fix(expInfo['Fix_Pos(pix)'], gaze, tolerance)
            if not good:
                vt_trials_fixation.color = tuple(name_to_rgb('red'))
            else:
                vt_trials_fixation.color = expInfo['Fix_Color']
            VT_trials_tracking['frameN'].append(frameN)
            VT_trials_tracking['routine_time'].append(t)
            VT_trials_tracking['global_time'].append(t_global)
            VT_trials_tracking['gaze'].append(gaze)
            VT_trials_tracking['good_fixation'].append(good)
        vt_trials_fixation.setAutoDraw(True)

        # Note that the flickering cursor switches its color according to frameN!!
        # so be cautious about actual framerate and the flickering rate you want
        if expInfo['Flickering(Hz)'] and frameN % flickering_frameRate == 0:
            if all(np.array(vt_trials_dot.color) == np.array(vt_trials_dot_ocolor_rgb)):
                vt_trials_dot.color = vt_trials_dot_rcolor_rgb
            elif all(np.array(vt_trials_dot.color) == np.array(vt_trials_dot_rcolor_rgb)):
                vt_trials_dot.color = vt_trials_dot_ocolor_rgb
            else: pass
        else: pass
        mouse_x, mouse_y = vt_tests[vt_n - 1], vt_trials_mouse.getPos()[1]
        vt_trials_dot.setPos(newPos = [mouse_x, mouse_y])
        clickreport = click_recorder(vt_trials_mouse, mouse_x, mouse_y, vt_clicks, eye_tracker = expInfo['Eye_Tracker'])
        if expInfo['Eye_Tracker']:
            VT_trials_tracking['click'].append(clickreport)
        vt_trials_dot.setAutoDraw(True)

    # *vt_trials_info*, and *vt_trials_dot_pos* updates
    if tThisFlip >= 0.0-frameTolerance and expInfo['Show_Raw_Data']:
        vt_trials_info.text = (f"Mode: {expInfo['Mode']}, Trial: V{vt_n}/V{vt_N}\nHT_points:\n{ht_dots}\nVT_points:\n"
                               f"{vt_dots}\n\nHT_clicks: \n{ht_clicks}\nVT_clicks: \n{vt_clicks}\ntime: \n{t}")
        vt_trials_info.setAutoDraw(True)
        vt_trials_dot_pos.text = f"X: {mouse_x}\nY: {mouse_y}"
        vt_trials_dot_pos.setAutoDraw(True)

    # *vt_trials_end* updates
    if not keyboard_start and tThisFlip >= 0.0-frameTolerance:
        win.callOnFlip(vt_trials_end.clearEvents, eventType='keyboard')  # clear events on next screen flip
        keyboard_start = True
    if keyboard_start:
        theseKeys = vt_trials_end.getKeys(keyList=['space', 'e', 'd'], waitRelease=False)
        if len(theseKeys):
            theseKeys = theseKeys[0]  # at least one key was pressed
            if theseKeys == 'd':
                expInfo['Show_Raw_Data'] = not expInfo['Show_Raw_Data']
                vt_trials_info.setAutoDraw(expInfo['Show_Raw_Data'])
                vt_trials_dot_pos.setAutoDraw(expInfo['Show_Raw_Data'])
            elif theseKeys == 'space':
                if vt_n < vt_N:
                    vt_n += 1
                else:
                    continueRoutine = False
                    vt_dots = dots_estimation(vt_clicks, axis = 1)
            elif theseKeys == 'e' and expInfo['Eye_Tracker']:
                win.winHandle.minimize()
                win.winHandle.set_fullscreen(False)
                tracker.setRecordingState(False)
                tracker.runSetupProcedure()
                tracker.setRecordingState(True)
                win.winHandle.maximize()
                win.winHandle.set_fullscreen(True)
                win.winHandle.activate()
        else: pass
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break    
    # refresh the screen
    elif continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()
if expInfo['Eye_Tracker']:
    VT_trials_tracking = pd.DataFrame(VT_trials_tracking)
    VT_trials_tracking['Participant'] = expInfo['Participant']
    VT_trials_tracking['Session'] = expInfo['Session']

# -------Ending Routine "VT_trials"-------

for thisComponent in VT_trials_autodraw:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# the Routine "VT_trials" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

###################################################################################


###################################################################################

# ------Prepare to start Routine "HD_start"-------

# Now prepare HD trials, HD measures the BS width.

routineTimer.add(1.000000)

# update component parameters for each repeat
HD_start_autodraw = [hd_start_fixation, hd_start_dot, hd_start_dot_pos, hd_start_info]

# reset timers
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
HD_startClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip

# initiate Routine
continueRoutine = True

# set the path
hd_tests = [np.array(vt_dots).mean(axis = 0)[1]]
hd_clicks = []
hd_dots = []

# reset path No.
hd_n = 1

# HD always has only 1 path
hd_N = 1

# -------Run Routine "HD_start"-------

beep_start = False
fixation_start = False
while continueRoutine and routineTimer.getTime() > 0:
    tThisFlip = win.getFutureFlipTime(clock=HD_startClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    # update/draw components on each frame
    # start/stop hd_start_beep
    if not beep_start and tThisFlip >= 0.0-frameTolerance:
        hd_start_beep.tStartRefresh = tThisFlipGlobal  # on global time
        hd_start_beep.play(when=win)  # sync with win flip
        beep_start = True
    if beep_start:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > hd_start_beep.tStartRefresh + 1.0-frameTolerance:
            hd_start_beep.stop()
    
    # *hd_start_fixation* updates
    if not fixation_start and tThisFlip >= 0.0-frameTolerance:
        hd_start_fixation.tStartRefresh = tThisFlipGlobal  # on global time
        hd_start_fixation.setAutoDraw(True)
        fixation_start = True
    if fixation_start:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > hd_start_fixation.tStartRefresh + 1-frameTolerance:
            hd_start_fixation.setAutoDraw(False)

    # *hd_start_info*, and *hd_start_dot_pos* updates
    if tThisFlip >= 0.0-frameTolerance and expInfo['Show_Raw_Data']:
        hd_start_info.text = (f"Mode: {expInfo['Mode']}, Trial: H{ht_n}/H{ht_N+1}\nHT_points:\n{ht_dots}\nVT_points:\n"
                              f"{vt_dots}\n\nHT_clicks: \n{ht_clicks}\nVT_clicks: \n{vt_clicks}\nHD_clicks: \n"
                              f"{hd_clicks}\nHD_points: \n{hd_dots}")
        hd_start_info.setAutoDraw(True)
        hd_start_dot_pos.text = f"X: {mouse_x}\nY: {mouse_y}"
        hd_start_dot_pos.setAutoDraw(True)

    # *hd_start_mouse* and *hd_start_dot* updates
    if tThisFlip >= 0.0-frameTolerance:
        mouse_x, mouse_y = hd_start_mouse.getPos()
        hd_start_dot.setPos(newPos = [mouse_x, mouse_y])
        hd_start_dot.setAutoDraw(True)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    # refresh the screen
    elif continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "HD_start"-------

for thisComponent in HD_start_autodraw:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
hd_start_beep.stop()  # ensure sound has stopped at end of routine

###################################################################################


###################################################################################

# ------Prepare to start Routine "HD_trials"-------

HD_trials_autodraw = [hd_trials_fixation, hd_trials_mouse, hd_trials_dot, 
                       hd_trials_dot_pos, hd_trials_info, hd_trials_end]

# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
HD_trialsClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# initiate Routine
continueRoutine = True
if expInfo['Eye_Tracker']:
    HD_trials_tracking = {'frameN': [], 'routine_time':[], 'global_time':[], 'gaze':[], 'good_fixation':[], 'click':[]}

# -------Run Routine "HD_trials"-------

hd_trials_mouse.clickReset()
hd_trials_dot_ocolor_rgb = [float(x) for x in hd_trials_dot.color]
hd_trials_dot_rcolor_rgb = [float(255 - x) for x in hd_trials_dot.color]
keyboard_start = False
while continueRoutine:
    # get current time
    t = HD_trialsClock.getTime()
    t_global = globalClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=HD_trialsClock)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *hd_trials_fixation*, *hd_trials_mouse* and *hd_trials_dot* updates
    if tThisFlip >= 0.0-frameTolerance:
        if expInfo['Eye_Tracker']:
            gaze = tracker.getPosition()
            if gaze is None:
                gaze = (99999, 99999)
            else: pass
            good = good_fix(expInfo['Fix_Pos(pix)'], gaze, tolerance)
            if not good:
                hd_trials_fixation.color = tuple(name_to_rgb('red'))
            else:
                hd_trials_fixation.color = expInfo['Fix_Color']
            HD_trials_tracking['frameN'].append(frameN)
            HD_trials_tracking['routine_time'].append(t)
            HD_trials_tracking['global_time'].append(t_global)
            HD_trials_tracking['gaze'].append(gaze)
            HD_trials_tracking['good_fixation'].append(good)
        hd_trials_fixation.setAutoDraw(True)

        # Note that the flickering cursor switches its color according to frameN!!
        # so be cautious about actual framerate and the flickering rate you want
        if expInfo['Flickering(Hz)'] and frameN % flickering_frameRate == 0:
            if all(np.array(hd_trials_dot.color) == np.array(hd_trials_dot_ocolor_rgb)):
                hd_trials_dot.color = hd_trials_dot_rcolor_rgb
            elif all(np.array(hd_trials_dot.color) == np.array(hd_trials_dot_rcolor_rgb)):
                hd_trials_dot.color = hd_trials_dot_ocolor_rgb
            else: pass
        else: pass

        mouse_x, mouse_y = hd_trials_mouse.getPos()[0], hd_tests[hd_n - 1]
        hd_trials_dot.setPos(newPos = [mouse_x, mouse_y])
        clickreport = click_recorder(hd_trials_mouse, mouse_x, mouse_y, hd_clicks, eye_tracker = expInfo['Eye_Tracker'])
        if expInfo['Eye_Tracker']:
            HD_trials_tracking['click'].append(clickreport)
        hd_trials_dot.setAutoDraw(True)

    # *hd_trials_info* and *hd_trials_dot_pos* updates
    if tThisFlip >= 0.0-frameTolerance and expInfo['Show_Raw_Data']:
        hd_trials_info.text = (f"Mode: {expInfo['Mode']}, Trial: H{ht_n+1}/H{ht_N+1}\nHT_points:\n{ht_dots}\n"
                               f"VT_points:\n{vt_dots}\n\nHT_clicks: \n{ht_clicks}\nVT_clicks: \n{vt_clicks}\n"
                               f"HD_clicks: \n{hd_clicks}\nHD_points: \n{hd_dots}\ntime: \n{t}")
        hd_trials_info.setAutoDraw(True)
        hd_trials_dot_pos.text = f"X: {mouse_x}\nY: {mouse_y}"
        hd_trials_dot_pos.setAutoDraw(True)

    # *hd_trials_end* updates
    if not keyboard_start and tThisFlip >= 0.0-frameTolerance:
        win.callOnFlip(hd_trials_end.clearEvents, eventType='keyboard')  # clear events on next screen flip
        keyboard_start = True
    if keyboard_start:
        theseKeys = hd_trials_end.getKeys(keyList=['space', 'e', 'd'], waitRelease=False)
        if len(theseKeys):
            theseKeys = theseKeys[0]  # at least one key was pressed
            if theseKeys == 'space':
                if hd_n < hd_N:
                    hd_n += 1
                else:
                    # a response ends the routine
                    continueRoutine = False
                    hd_dots = dots_estimation(hd_clicks, axis = 0)
            elif theseKeys == 'd':
                expInfo['Show_Raw_Data'] = not expInfo['Show_Raw_Data']
                hd_trials_info.setAutoDraw(expInfo['Show_Raw_Data'])
                hd_trials_dot_pos.setAutoDraw(expInfo['Show_Raw_Data'])
            elif theseKeys == 'e' and expInfo['Eye_Tracker']:
                win.winHandle.minimize()
                win.winHandle.set_fullscreen(False)
                tracker.setRecordingState(False)
                tracker.runSetupProcedure()
                tracker.setRecordingState(True)
                win.winHandle.maximize()
                win.winHandle.set_fullscreen(True)
                win.winHandle.activate()
        else: pass
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    # refresh the screen
    elif continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()
if expInfo['Eye_Tracker']:
    HD_trials_tracking = pd.DataFrame(HD_trials_tracking)
    HD_trials_tracking['Participant'] = expInfo['Participant']
    HD_trials_tracking['Session'] = expInfo['Session']

# -------Ending Routine "HD_trials"-------

for thisComponent in HD_trials_autodraw:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)

###################################################################################

# now combine HD and HT clicks
ht_clicks = ht_clicks + hd_clicks

# Before combining HD and HT dots, lets calculate the BS center
bs_center = (np.array(ht_dots).mean(axis = 0)[0], np.array(vt_dots).mean(axis = 0)[1])

# If you select 'Low' mode, assume that only width, height and center are of interest,
# so the HT dots are not needed and can be excluded to save time spent on staircase.
if expInfo['Mode'] == 'Low':
    ht_dots = hd_dots
else:
    ht_dots = ht_dots + hd_dots
routineTimer.reset()

###################################################################################


###################################################################################

# ------Prepare to start Routine "Staircase"-------
# Staircase procedures are section 2 of the whole experiment.
# This section calibrates the dots estimated in section 1.
# Given a particular n-down-n-up (nDnU) setting, each dot is of the same metrical
# meaning (percent invisibility/visibility) for all participants.
#
# Theoretically, 
# 2D1U, 3D1U, 4D1U, 5D1U, 6D1U staircases should target 
# 0.71, 0.79, 0.84, 0.87, 0.89 thresholds,
# while the amount of trials influences std.
# The default setting is 3D1U staircase.

# update component parameters for each repeat
Staircase_autodraw = [staircase_fixation, staircase_info, staircase_target]
dot_ocolor_rgb = [x for x in staircase_target.color]
dot_rcolor_rgb = [255 - x for x in staircase_target.color]
raw_vertices = ht_dots + vt_dots
raw_vertices = order_dots(raw_vertices) # raw vertices are border points before staircase
vertices = [] # vertices are border points after staircase
event.clearEvents()
frameN = -1
if expInfo['Eye_Tracker']:
    Staircase_tracking = {'frameN': [], 'routine_time':[], 'global_time':[], 'condition':[], 'gaze':[], 'good_fixation':[], 'button':[], 'stimulus_display':[], 'recorded_response':[]}

# -------Run Routine "Staircase"-------

if expInfo['Staircase']:
    run = True
    ready = False
    offset = False
    # Note that the duration is anchored to frameN!!
    # so be cautious about the actual framerate and duration you want
    duration = staircaseInfo['Staircase_Target_Display(s)']
    duration_frames = round(duration / frameDur)
    staircase_data = {}
    Staircase_global_clock = core.Clock()
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    StaircaseClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    # a beep indicating the start of staircase procedure.
    beep_start = False
    if not beep_start:
        start_time = globalClock.getTime()
        staircase_start_beep.play(when=win)  # sync with win flip
        beep_start = True
    while beep_start:
        # is it time to stop? (based on global clock, using actual start)
        if globalClock.getTime() - start_time > 1:
            staircase_start_beep.stop()
            beep_start = False
        else: pass  
else:
    run = False
    vertices = raw_vertices
    staircase_trials = None
    thisIncrement = None

# staircase should not be added into StaircaseComponents
# This section is basicaly a 2-level nested loop.
# The 1st level iterates all border points.
# The 2nd level iterates staircase increment values.
# 1st level, all border points
for dot in raw_vertices:
    increment_list = []
    if run == False: break
    dist = distance(dot, bs_center)
    staircase = data.StairHandler(startVal = staircaseInfo['InitialVal(pix)'], 
                                  nReversals=staircaseInfo['nReversals'], 
                                  stepSizes=staircaseInfo['Step_Sizes(pix)'], 
                                  nTrials=staircaseInfo['Staircase_Trials'], 
                                  nUp=staircaseInfo['nUp'], nDown=staircaseInfo['nDown'], 
                                  extraInfo=None, stepType='lin', 
                                  minVal=-dist, maxVal=dist, originPath=None, 
                                  name='staircase', autoLog=False)
    staircase_trials = 0
    # calculate the angle (in radians)
    deg = math.atan2(dot[1]-bs_center[1], dot[0]-bs_center[0])
    s = np.sin(deg)
    c = np.cos(deg)
    # 2nd level, all staircase increments
    for thisIncrement in staircase:
        if run == False: break
        staircase_trials = staircase_trials + 1
        increment_list.append((staircase_trials, thisIncrement))
        thisResp = None
        # reset timers
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        doUCit_start = False
        keyboard_start = False
        continueRoutine = True
        staircase_target.color = dot_ocolor_rgb
        while continueRoutine:
            t = StaircaseClock.getTime()
            t_global = globalClock.getTime()
            tThisFlip = win.getFutureFlipTime(clock=StaircaseClock)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN += 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            # start/stop staircase_doUCit
            if not doUCit_start and tThisFlip >= 0.0-frameTolerance and ready and offset:
                staircase_doUCit.tStartRefresh = tThisFlipGlobal  # on global time
                staircase_doUCit.play(when=win)  # sync with win flip
                doUCit_start = True
            if doUCit_start:
                if tThisFlipGlobal > staircase_doUCit.tStartRefresh + 1.05-frameTolerance:
                    staircase_doUCit.stop()
        
            # *staircase_fixation* and *staircase_target* updates
            if tThisFlip >= 0.0-frameTolerance:
                if offset:
                    staircase_fixation.opacity = 0
                else:
                    staircase_fixation.opacity = 1
                if expInfo['Eye_Tracker']:
                    gaze = tracker.getPosition()
                    if gaze is None:
                        gaze = (99999, 99999)
                    else: pass
                    good = good_fix(expInfo['Fix_Pos(pix)'], gaze, tolerance)
                    if not good:
                        staircase_fixation.color = tuple(name_to_rgb('red'))
                    else:
                        staircase_fixation.color = expInfo['Fix_Color']
                    Staircase_tracking['frameN'].append(frameN)
                    Staircase_tracking['routine_time'].append(t)
                    Staircase_tracking['global_time'].append(t_global)
                    Staircase_tracking['gaze'].append(gaze)
                    Staircase_tracking['good_fixation'].append(good)
                    Staircase_tracking['condition'].append(dot)
                staircase_fixation.setAutoDraw(True)

                if ready:
                    staircase_target.setPos(newPos = [dot[0] - c*thisIncrement, dot[1] - s*thisIncrement])
                    # if the participant triggers the target object, set it visible.
                    staircase_target.opacity = 1
                    # Note that the flickering cursor switches its color according to frameN!!
                    # so be cautious about actual framerate and the flickering rate you want
                    if expInfo['Flickering(Hz)'] and frameN % flickering_frameRate == 0 and frameN <= offset_frameN:
                        if all(staircase_target.color) == all(dot_ocolor_rgb):
                            staircase_target.color = dot_rcolor_rgb
                        elif all(staircase_target.color) == all(dot_rcolor_rgb):
                            staircase_target.color = dot_ocolor_rgb
                        else: pass
                    elif frameN > offset_frameN:
                        staircase_target.opacity = 0
                        offset = True
                else:
                    staircase_target.opacity = 0
                    offset = False
                staircase_target.setAutoDraw(True)

            # *staircase_info* updates
            if tThisFlip >= 0.0-frameTolerance and expInfo['Show_Raw_Data']:
                staircase_info.text = (f"Flickering rate(frames between flips): {flickering_frameRate}\n"
                                       f"Display duration(frames): {duration_frames}\nFrameN: {frameN}\n\n"
                                       f"Mode: {expInfo['Mode']}, Trial: staircase\nstaircase_trials: {staircase_trials}\n"
                                       f"thisIncrement: {thisIncrement}\n\nvertices: {vertices}\ntime: {t}")
                staircase_info.setAutoDraw(True)

            # *staircase_end* updates
            if not keyboard_start and tThisFlip >= 0.0-frameTolerance:
                win.callOnFlip(staircase_end.clearEvents, eventType='keyboard')  # clear events on next screen flip
                event.clearEvents()
                keyboard_start = True
            if keyboard_start:
                theseKeys = staircase_end.getKeys(keyList=['space', 'left', 'right', 'e', 'd'], waitRelease=False)
                if len(theseKeys):
                    theseKeys = theseKeys[0]  # at least one key was pressed
                    # check for quit:
                    if theseKeys == 'e' and expInfo['Eye_Tracker']:
                        theseKeys = theseKeys.name
                        win.winHandle.minimize()
                        win.winHandle.set_fullscreen(False)
                        tracker.setRecordingState(False)
                        tracker.runSetupProcedure()
                        tracker.setRecordingState(True)
                        win.winHandle.maximize()
                        win.winHandle.set_fullscreen(True)
                        win.winHandle.activate()
                    elif theseKeys == 'd':
                        theseKeys = theseKeys.name
                        expInfo['Show_Raw_Data'] = not expInfo['Show_Raw_Data']
                        staircase_info.setAutoDraw(expInfo['Show_Raw_Data'])
                    elif not ready:
                        if theseKeys == 'space':
                            theseKeys = theseKeys.name
                            staircase_target.color = dot_ocolor_rgb
                            if not expInfo['Eye_Tracker']:
                                continueRoutine = True
                                ready = True
                                onset_time = core.getTime()
                                onset_frameN = frameN # but the target will be displayed on the next frame.
                                offset_frameN = onset_frameN + duration_frames
                            elif good:
                                continueRoutine = True
                                ready = True
                                onset_time = core.getTime()
                                onset_frameN = frameN
                                offset_frameN = onset_frameN + duration_frames
                    elif ready:
                        if theseKeys == 'right' and offset:
                            theseKeys = theseKeys.name
                            offset = False
                            if not expInfo['Eye_Tracker']:
                                continueRoutine = False
                                thisResp = 0
                                ready = False
                                core.wait(staircaseInfo['Staircase_Latency(s)'])
                            elif not sum_bad_fixation(Staircase_tracking, onset_frameN, offset_frameN, time_back = 0.03, framedur = frameDur):
                                continueRoutine = False
                                thisResp = 0
                                ready = False
                                core.wait(staircaseInfo['Staircase_Latency(s)'])
                            else:
                                continueRoutine = True
                                doUCit_start = False
                                ready = False
                                core.wait(staircaseInfo['Staircase_Latency(s)'])
                        elif theseKeys == 'left' and offset:
                            theseKeys = theseKeys.name
                            offset = False
                            if not expInfo['Eye_Tracker']:
                                continueRoutine = False
                                thisResp = 1
                                ready = False
                                core.wait(staircaseInfo['Staircase_Latency(s)'])
                            elif not sum_bad_fixation(Staircase_tracking, onset_frameN, offset_frameN, time_back = 0.03, framedur = frameDur):
                                continueRoutine = False
                                thisResp = 1
                                ready = False
                                core.wait(staircaseInfo['Staircase_Latency(s)'])
                            else:
                                continueRoutine = True
                                doUCit_start = False
                                ready = False
                                core.wait(staircaseInfo['Staircase_Latency(s)'])
                else:
                    theseKeys = 'None'
                if expInfo['Eye_Tracker']:
                    Staircase_tracking['button'].append(theseKeys)
                    Staircase_tracking['stimulus_display'].append(ready and not offset)
                    Staircase_tracking['recorded_response'].append(str(thisResp))
                    

            # check for quit (typically the Esc key)
            if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                core.quit()
    
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                break  
            # refresh the screen
            elif continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        staircase.addResponse(thisResp)
        continueRoutine = True
        if staircase_trials < staircase.nTrials:
            pass
        elif staircase_trials == staircase.nTrials:
            dot_after_staircase = (dot[0] - c* thisIncrement, dot[1] - s*thisIncrement)
    staircase_data[f'{dot}'] = increment_list
    try:
        dot_name = '(%.1f, %.1f)' % (dot[0], dot[1])
        staircase.saveAsPickle(filename + dot_name) # this file can be analyzed by psychopy official demo
    except Exception: pass
    vertices.append(dot_after_staircase)

if expInfo['Staircase']:
    staircaseInfo['Staircase_Data'] = staircase_data
    staircase_data = pd.DataFrame(dict([(k, pd.Series(v)) for k, v in staircase_data.items()]))
else: pass
if expInfo['Eye_Tracker']:
    Staircase_tracking = pd.DataFrame(Staircase_tracking)
    Staircase_tracking['Participant'] = expInfo['Participant']
    Staircase_tracking['Session'] = expInfo['Session']

bs_width, bs_height = np.array(vertices).max(axis = 0) - np.array(vertices).min(axis = 0)

# -------Ending Routine "Staircase"-------

for thisComponent in Staircase_autodraw:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
routineTimer.reset()

###################################################################################


###################################################################################

# ------Prepare to start Routine "Validation"-------

# Validation section is the final section.
# Based on the data from sections 1 and 2, validation section estimates the actual
# visibility of the estimated blind spot region. ("Scaling")

# There is another "Heat_Map" procedure to map the blind spot in more detail. It is
# more than a validation.

# now prepare validation
if expInfo['Validation'] == 'Scaling':
    # size coefficients, the default are 10 values ranging from 0.6 to 1.2
    diameter_coefficients = np.linspace(*validationInfo['Scaling_Range(portion)'], validationInfo['Scaling_Steps']).round(decimals = 2)

    validation_data = pd.DataFrame(np.zeros((1, validationInfo['Scaling_Steps']), dtype = int), 
                                  index = ['visible'], 
                                  columns = diameter_coefficients)
    coef_list = [x for x in diameter_coefficients]
    validation_data_exist = True
    # the default is 10 repetitions
    repeats = validationInfo['Repeats']
    duration = validationInfo['Scaling_Target_Display(s)']
    duration_frames = round(duration / frameDur)
    latency = validationInfo['Scaling_Latency(s)']


elif expInfo['Validation'] == 'Heat_Map':
    # heat map sizes (w X h), they should be slightly bigger than estimated blind spot. so the default is 1.1 bs_w X 1.2 bs_h.
    grid_height = validationInfo['Grid_Height(portion)'] * bs_height
    grid_width = validationInfo['Grid_Width(portion)'] * bs_width
    target_width = grid_width / validationInfo['Columns']
    target_height = grid_height / validationInfo['Rows']

    grid_left = bs_center[0] - (grid_width / 2)
    grid_right = bs_center[0] + (grid_width / 2)
    grid_bottom = bs_center[1] - (grid_height / 2)
    grid_top = bs_center[1] + (grid_height / 2)

    target_center_left = bs_center[0] - ((grid_width - target_width) / 2)
    target_center_right = bs_center[0] + ((grid_width - target_width) / 2)
    target_center_bottom = bs_center[1] - ((grid_height - target_height) / 2)
    target_center_top = bs_center[1] + ((grid_height - target_height) / 2)
    target_center_x = np.linspace(target_center_left, target_center_right, validationInfo['Columns']).round(decimals = 2)
    target_center_y = np.linspace(target_center_top, target_center_bottom, validationInfo['Rows']).round(decimals = 2)
    pos_list = [(x, y) for x in target_center_x for y in target_center_y]

    validation_data = pd.DataFrame(np.zeros((validationInfo['Rows'], validationInfo['Columns']), dtype = int), 
                                  index = target_center_y, 
                                  columns = target_center_x)
    validation_data_exist = True
    # the default is 10 repetitions
    repeats = validationInfo['Repeats']
    duration = validationInfo['Heat_Map_Target_Display(s)']
    duration_frames = round(duration / frameDur)
    latency = validationInfo['Heat_Map_Latency(s)']


elif expInfo['Validation'] == 'No':
    switch = False
    validation_data_exist = False

if expInfo['Eye_Tracker']:
    Validation_tracking = {'frameN': [], 'routine_time':[], 'global_time':[], 'condition':[], 'gaze':[], 'good_fixation':[], 'button':[], 'stimulus_display':[], 'recorded_response':[]}


# -------Run Routine "Validation"-------

Validation_autodraw = [validation_fixation, validation_info, validation_target]
if expInfo['Validation'] != 'No':
    dot_ocolor_rgb = [x for x in expInfo['Cursor_Color']]
    dot_rcolor_rgb = [255 - x for x in expInfo['Cursor_Color']]
    event.clearEvents()
    ready = False
    offset = False
    doUCit_start = False
    keyboard_start = False
    # reset timers
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    ValidationClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    Validation_global_clock = core.Clock()
    frameN = -1
    t = 0
    beep_start = False
    if not beep_start:
        start_time = globalClock.getTime()
        validation_start_beep.play(when=win)  # sync with win flip
        beep_start = True
    while beep_start:
        # is it time to stop? (based on global clock, using actual start)
        if globalClock.getTime() - start_time > 1:
            validation_start_beep.stop()
            beep_start = False
        else: pass 
else: pass

# This Scaling procedure is basicaly a 2-level nested loop
# The 1st level is repetition 
# The 2nd level iterates all size coefs randomly.
if expInfo['Validation'] == 'Scaling':
    frameN = -1
    ValidationClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    # 1st level, repetition
    for cycle in range(repeats):
        trial = 0
        shuffle(coef_list)
        # 2nd level, iterates all size coefs.
        for coef in coef_list:
            trial += 1
            thisResp = None
            ready = False
            offset = False
            doUCit_start = False
            keyboard_start = False
            # reset timers
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")

            # initiate Routine
            continueRoutine = True
            while continueRoutine:
                t = ValidationClock.getTime()
                t_global = globalClock.getTime()
                tThisFlip = win.getFutureFlipTime(clock=ValidationClock)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN += 1  # number of completed frames (so 0 is the first frame)
                        
                # update/draw components on each frame
                # start/stop validation_doUCit
                if not doUCit_start and tThisFlip >= 0.0-frameTolerance and ready and offset:
                    validation_doUCit.tStartRefresh = tThisFlipGlobal  # on global time
                    validation_doUCit.play(when=win)  # sync with win flip
                    doUCit_start = True
                if doUCit_start:
                    if tThisFlipGlobal > validation_doUCit.tStartRefresh + 1.05-frameTolerance:
                        validation_doUCit.stop()
        
                # *validation_fixation* and *validation_target* updates
                if tThisFlip >= 0.0-frameTolerance:
                    if offset:
                        validation_fixation.opacity = 0
                    else:
                        validation_fixation.opacity = 1
                    if expInfo['Eye_Tracker']:
                        gaze = tracker.getPosition()
                        if gaze is None:
                            gaze = (99999, 99999)
                        else: pass
                        good = good_fix(expInfo['Fix_Pos(pix)'], gaze, tolerance)
                        if not good:
                            validation_fixation.color = tuple(name_to_rgb('red'))
                        else:
                            validation_fixation.color = expInfo['Fix_Color']
                        Validation_tracking['frameN'].append(frameN)
                        Validation_tracking['routine_time'].append(t)
                        Validation_tracking['global_time'].append(t_global)
                        Validation_tracking['gaze'].append(gaze)
                        Validation_tracking['good_fixation'].append(good)
                        Validation_tracking['condition'].append(coef)
                    validation_fixation.setAutoDraw(True)
                            
                    validation_target.setPos(newPos = bs_center, )
                    validation_target.setSize(newSize = (coef * bs_width, coef * bs_height))
                    if ready:
                        if frameN <= offset_frameN:
                            validation_target.opacity = 1
                        elif frameN > offset_frameN: 
                            validation_target.opacity = 0
                            offset = True
                    else:
                        validation_target.opacity = 0
                        offset = False
                validation_target.setAutoDraw(True)

                # *validation_info* updates
                if tThisFlip >= 0.0-frameTolerance and expInfo['Show_Raw_Data']:
                    validation_info.text = (f"Flickering rate(frames between flips): {flickering_frameRate}\n"
                                            f"Display duration(frames): {duration_frames}\nFrameN: {frameN}\n\n"
                                            f"Validation: trial{trial}/{len(diameter_coefficients)}, "
                                            f"cycle{cycle + 1}/{repeats}\nthisSize: {coef} * Diameters\ntime: {t}")
                    validation_info.setAutoDraw(True)

                # *validation_end* updates
                if not keyboard_start and tThisFlip >= 0.0-frameTolerance:
                    win.callOnFlip(validation_end.clearEvents, eventType='keyboard')  # clear events on next screen flip
                    event.clearEvents()
                    keyboard_start = True
                if keyboard_start:
                    theseKeys = validation_end.getKeys(keyList=['space', 'left', 'right', 'e', 'd'], waitRelease=False)
                    if len(theseKeys):
                        theseKeys = theseKeys[0]  # at least one key was pressed
                        if theseKeys == 'd':
                            theseKeys = theseKeys.name
                            expInfo['Show_Raw_Data'] = not expInfo['Show_Raw_Data']
                            validation_info.setAutoDraw(expInfo['Show_Raw_Data'])
                        elif theseKeys == 'e' and expInfo['Eye_Tracker']:
                            theseKeys = theseKeys.name
                            win.winHandle.minimize()
                            win.winHandle.set_fullscreen(False)
                            tracker.setRecordingState(False)
                            tracker.runSetupProcedure()
                            tracker.setRecordingState(True)
                            win.winHandle.maximize()
                            win.winHandle.set_fullscreen(True)
                            win.winHandle.activate()
                        elif not ready:
                            if theseKeys == 'space':
                                theseKeys = theseKeys.name
                                if not expInfo['Eye_Tracker']:
                                    continueRoutine = True
                                    ready = True
                                    onset_time = core.getTime()
                                    onset_frameN = frameN
                                    offset_frameN = frameN + duration_frames 
                                elif good:
                                    continueRoutine = True
                                    ready = True
                                    onset_time = core.getTime()
                                    onset_frameN = frameN
                                    offset_frameN = frameN + duration_frames
                        elif ready:
                            if theseKeys == 'right' and offset:
                                theseKeys = theseKeys.name
                                offset = False
                                if not expInfo['Eye_Tracker']:
                                    continueRoutine = False
                                    thisResp = 1
                                    ready = False
                                    core.wait(latency)
                                elif not sum_bad_fixation(Validation_tracking, onset_frameN, offset_frameN, time_back = 0.03, framedur = frameDur):
                                    continueRoutine = False
                                    thisResp = 1
                                    ready = False
                                    core.wait(latency)
                                else:
                                    continueRoutine = True
                                    doUCit_start = False
                                    ready = False
                                    core.wait(latency)
                            elif theseKeys == 'left' and offset:
                                theseKeys = theseKeys.name
                                offset = False
                                if not expInfo['Eye_Tracker']:
                                    continueRoutine = False
                                    thisResp = 0
                                    ready = False
                                    core.wait(latency)
                                elif not sum_bad_fixation(Validation_tracking, onset_frameN, offset_frameN, time_back = 0.03, framedur = frameDur):
                                    continueRoutine = False
                                    thisResp = 0
                                    ready = False
                                    core.wait(latency)
                                else:
                                    continueRoutine = True
                                    doUCit_start = False
                                    ready = False
                                    core.wait(latency)     
                    else:
                        theseKeys = 'None'
                    if expInfo['Eye_Tracker']:
                        Validation_tracking['button'].append(theseKeys)
                        Validation_tracking['stimulus_display'].append(ready and not offset)
                        Validation_tracking['recorded_response'].append(str(thisResp))
                # check for quit (typically the Esc key)
                if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                    core.quit()
    
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    break  
                # refresh the screen
                elif continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            validation_data[coef]['visible'] += thisResp
                    
# This Heat_Map procedrue is basicaly a 2-level nested loop
# The 1st level is repetition 
# The 2nd level iterates all stimuli (cell) positions randomly.
elif expInfo['Validation'] == 'Heat_Map':
    frameN = -1
    ValidationClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    for cycle in range(repeats):
        trial = 0
        shuffle(pos_list)
        for pos in pos_list:
            trial += 1
            thisResp = None
            ready = False
            offset = False
            doUCit_start = False
            keyboard_start = False
            # reset timers
            _timeToFirstFrame = win.getFutureFlipTime(clock="now")

            # initiate Routine
            continueRoutine = True
            while continueRoutine:
                t = ValidationClock.getTime()
                t_global = globalClock.getTime()
                tThisFlip = win.getFutureFlipTime(clock=ValidationClock)
                tThisFlipGlobal = win.getFutureFlipTime(clock=None)
                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)

                # update/draw components on each frame
                # start/stop validation_doUCit
                if not doUCit_start and tThisFlip >= 0.0-frameTolerance and ready and offset:
                    validation_doUCit.tStartRefresh = tThisFlipGlobal  # on global time
                    validation_doUCit.play(when=win)  # sync with win flip
                    doUCit_start = True
                if doUCit_start:
                    if tThisFlipGlobal > validation_doUCit.tStartRefresh + 1.05-frameTolerance:
                        validation_doUCit.stop()
        
                # *validation_fixation* and *validation_target* updates
                if tThisFlip >= 0.0-frameTolerance:
                    if offset:
                        validation_fixation.opacity = 0
                    else:
                        validation_fixation.opacity = 1
                    if expInfo['Eye_Tracker']:
                        gaze = tracker.getPosition()
                        if gaze is None:
                            gaze = (99999, 99999)
                        else: pass
                        good = good_fix(expInfo['Fix_Pos(pix)'], gaze, tolerance)
                        if not good:
                            validation_fixation.color = tuple(name_to_rgb('red'))
                        else:
                            validation_fixation.color = expInfo['Fix_Color']
                        Validation_tracking['frameN'].append(frameN)
                        Validation_tracking['routine_time'].append(t)
                        Validation_tracking['global_time'].append(t_global)
                        Validation_tracking['gaze'].append(gaze)
                        Validation_tracking['good_fixation'].append(good)
                        Validation_tracking['condition'].append(pos)
                    validation_fixation.setAutoDraw(True)

                    if ready:
                        validation_target.setPos(newPos = pos)
                        validation_target.setWidth(target_width)
                        validation_target.setHeight(target_height)
                        if expInfo['Flickering(Hz)'] and frameN % flickering_frameRate == 0 and frameN <= offset_frameN:
                            if all(validation_target.fillColor) == all(dot_ocolor_rgb):
                                validation_target.fillColor = dot_rcolor_rgb
                            elif all(validation_target.fillColor) == all(dot_rcolor_rgb):
                                validation_target.fillColor = dot_ocolor_rgb
                            else: pass
                        elif frameN > offset_frameN: 
                            validation_target.fillColor = expInfo['BG_Color']
                            offset = True
                    else:
                        validation_target.fillColor = expInfo['BG_Color']
                        offset = False
                validation_target.setAutoDraw(True)

                # *validation_info* updates
                if tThisFlip >= 0.0-frameTolerance and expInfo['Show_Raw_Data']:
                    validation_info.text = (f"Flickering rate(frames between flips): {flickering_frameRate}\n"
                                            f"Display duration(frames)\nFrameN: {frameN}\n\n"
                                            f"Validation: trial{trial}/{len(pos_list)}, cycle{cycle + 1}/{repeats}\n"
                                            f"thisPos: {pos}\ntime: {t}")
                    validation_info.setAutoDraw(True)

                # *validation_end* updates
                if not keyboard_start and tThisFlip >= 0.0-frameTolerance:
                    win.callOnFlip(validation_end.clearEvents, eventType='keyboard')  # clear events on next screen flip
                    event.clearEvents()
                    keyboard_start = True
                if keyboard_start:
                    theseKeys = validation_end.getKeys(keyList=['space', 'left', 'right', 'e', 'd'], waitRelease=False)
                    if len(theseKeys):
                        theseKeys = theseKeys[0]  # at least one key was pressed
                        if theseKeys == 'd':
                            theseKeys = theseKeys.name
                            expInfo['Show_Raw_Data'] = not expInfo['Show_Raw_Data']
                            validation_info.setAutoDraw(expInfo['Show_Raw_Data'])
                        elif theseKeys == 'e' and expInfo['Eye_Tracker']:
                            theseKeys = theseKeys.name
                            win.winHandle.minimize()
                            win.winHandle.set_fullscreen(False)
                            tracker.setRecordingState(False)
                            tracker.runSetupProcedure()
                            tracker.setRecordingState(True)
                            win.winHandle.maximize()
                            win.winHandle.set_fullscreen(True)
                            win.winHandle.activate()
                        elif not ready:
                            if theseKeys == 'space':
                                theseKeys = theseKeys.name
                                if not expInfo['Eye_Tracker']:
                                    continueRoutine = True
                                    ready = True
                                    onset_time = core.getTime()
                                    onset_frameN = frameN
                                    offset_frameN = onset_frameN + duration_frames
                                elif good:
                                    continueRoutine = True
                                    ready = True
                                    onset_time = core.getTime()
                                    onset_frameN = frameN
                                    offset_frameN = onset_frameN + duration_frames
                        elif ready:
                            if theseKeys == 'right' and offset:
                                theseKeys = theseKeys.name
                                offset = False
                                if not expInfo['Eye_Tracker']:
                                    continueRoutine = False
                                    thisResp = 1
                                    ready = False
                                    core.wait(latency)
                                elif not sum_bad_fixation(Validation_tracking, onset_frameN, offset_frameN, time_back = 0.03, framedur = frameDur):
                                    continueRoutine = False
                                    thisResp = 1
                                    ready = False
                                    core.wait(latency)
                                else:
                                    continueRoutine = True
                                    doUCit_start = False
                                    ready = False
                                    core.wait(latency)
                            elif theseKeys == 'left' and offset:
                                theseKeys = theseKeys.name
                                offset = False
                                if not expInfo['Eye_Tracker']:
                                    continueRoutine = False
                                    thisResp = 0
                                    ready = False
                                    core.wait(latency)
                                elif not sum_bad_fixation(Validation_tracking, onset_frameN, offset_frameN, time_back = 0.03, framedur = frameDur):
                                    continueRoutine = False
                                    thisResp = 0
                                    ready = False
                                    core.wait(latency)
                                else:
                                    continueRoutine = True
                                    doUCit_start = False
                                    ready = False
                                    core.wait(latency)
                    else:
                        theseKeys = 'None'
                    if expInfo['Eye_Tracker']:
                        Validation_tracking['button'].append(theseKeys)
                        Validation_tracking['stimulus_display'].append(ready and not offset)
                        Validation_tracking['recorded_response'].append(str(thisResp))

                # check for quit (typically the Esc key)
                if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                    core.quit()
    
                # check if all components have finished
                if not continueRoutine:  # a component has requested a forced-end of Routine
                    break  
                # refresh the screen
                elif continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                    win.flip()
            validation_data[pos[0]][pos[1]] += thisResp

if validation_data_exist: 
    visible_rate = validation_data / repeats
    visible_rate['Participant'] = expInfo['Participant']
    visible_rate['Session'] = expInfo['Session']
if expInfo['Eye_Tracker']:
    Validation_tracking = pd.DataFrame(Validation_tracking)
    Validation_tracking['Participant'] = expInfo['Participant']
    Validation_tracking['Session'] = expInfo['Session']

# -------Ending Routine "validation"-------

for thisComponent in Validation_autodraw:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
routineTimer.reset()

###################################################################################


###################################################################################

# ------Prepare to start Routine "Test_complete"-------

Test_complete_autodraw = [test_complete, test_complete_dot, test_complete_dot_pos, 
                           test_complete_info, test_complete_fixation]
# reset timers
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Test_completeClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip

# initiate Routine
continueRoutine = True

# sort vertices for drwaing the BS
vertices = order_dots(vertices) # data processing for drawing the BS in the next routine

# -------Run Routine "Test_complete"-------

keyboard_start = False
while continueRoutine:
    tThisFlip = win.getFutureFlipTime(clock=Test_completeClock)
    # update/draw components on each frame
    
    # *test_complete*, *test_complete_fixation*, *test_complete_mouse* and *test_complete_dot* updates
    if tThisFlip >= 0.0-frameTolerance:
        test_complete.setAutoDraw(True)
        test_complete_fixation.setAutoDraw(True)
        mouse_x, mouse_y = test_complete_mouse.getPos()
        test_complete_dot.setPos(newPos = [mouse_x, mouse_y])
        test_complete_dot.setAutoDraw(True)

    # *test_complete_info* and *test_complete_dot_pos* updates
    if tThisFlip >= 0.0-frameTolerance and expInfo['Show_Raw_Data']:
        test_complete_info.text = (f"Mode: {expInfo['Mode']}, \nHT_points:\n{ht_dots}\nVT_points:\n{vt_dots}\n\n"
                                   f"HT_clicks: \n{ht_clicks}\nVT_clicks: \n{vt_clicks}\n"
                                   f"raw_vertices: \n{raw_vertices}\n\nvertices: {vertices}\nbs_center: {bs_center}")
        test_complete_info.setAutoDraw(True)
        test_complete_dot_pos.text = f"X: {mouse_x}\nY: {mouse_y}"
        test_complete_dot_pos.setAutoDraw(True)
    
    # *test_complete_end* updates
    if not keyboard_start and tThisFlip >= 0.0-frameTolerance:
        win.callOnFlip(test_complete_end.clearEvents, eventType='keyboard')  # clear events on next screen flip
        keyboard_start = True
    if keyboard_start:
        theseKeys = test_complete_end.getKeys(keyList=['space', 'd'], waitRelease=False)
        if len(theseKeys):
            theseKeys = theseKeys[0]  # at least one key was pressed
            # check for quit:
            if theseKeys == 'space':
                # a response ends the routine
                continueRoutine = False
            elif theseKeys == 'd':
                expInfo['Show_Raw_Data'] = not expInfo['Show_Raw_Data']
                test_complete_info.setAutoDraw(expInfo['Show_Raw_Data'])
                test_complete_dot_pos.setAutoDraw(expInfo['Show_Raw_Data'])
            
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    # refresh the screen
    elif continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Test_complete"-------

for thisComponent in Test_complete_autodraw:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# the Routine "Test_complete" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

###################################################################################


###################################################################################

# ------Prepare to start Routine "Mapping_result"-------

Mapping_result_autodraw = [mapping_result, test_fixation, mapping_result_bs, 
                           mapping_result_dot, mapping_result_dot_pos, mapping_result_info]
# reset timers
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
Mapping_resultClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip

# initiate Routine
continueRoutine = True
frameN = -1

# -------Run Routine "Mapping_result"-------

while continueRoutine:
    t = Mapping_resultClock.getTime()
    t_global = globalClock.getTime()
    frameN += 1
    tThisFlip = win.getFutureFlipTime(clock=Mapping_resultClock)
    # update/draw components on each frame
    
    # *mapping_result* updates
    if tThisFlip >= 0.0-frameTolerance:
        mapping_result.setAutoDraw(True)
    
    # *test_fixation* updates
    if tThisFlip >= 0.0-frameTolerance:
        if expInfo['Eye_Tracker']:
            gaze = tracker.getPosition()
            if gaze is None:
                gaze = (99999, 99999)
            else:
                pass
            good = good_fix(expInfo['Fix_Pos(pix)'], gaze, tolerance)
            if not good:
                test_fixation.color = tuple(name_to_rgb('red'))
            else:
                test_fixation.color = expInfo['Fix_Color']
        test_fixation.setAutoDraw(True)
    
    # *mapping_result_bs* updates
    if tThisFlip >= 0.0-frameTolerance:
        # draw a blind spot region
        mapping_result_bs.vertices = vertices
        mapping_result_bs.setAutoDraw(True)

    # *mapping_result_info* updates
    if tThisFlip >= 0.0-frameTolerance and expInfo['Show_Raw_Data']:
        mapping_result_info.text = (f"Mode: {expInfo['Mode']}, \nHT_points:\n{ht_dots}\nVT_points:\n{vt_dots}\n\n"
                                    f"HT_clicks: \n{ht_clicks}\nVT_clicks: \n{vt_clicks}\n"
                                    f"raw_vertices: \n{raw_vertices}\nvertices: {vertices}\nbs_center: {bs_center}")
        mapping_result_info.setAutoDraw(True)

    # *mapping_result_mouse* and *mapping_result_dot* updates
    if tThisFlip >= 0.0-frameTolerance:
        mouse_x, mouse_y = mapping_result_mouse.getPos()
        mapping_result_dot.setPos(newPos = [mouse_x, mouse_y])
        mapping_result_dot.setAutoDraw(True)

    # *mapping_result_dot_pos* updates
    if tThisFlip >= 0.0-frameTolerance and expInfo['Show_Raw_Data']:
        mapping_result_dot_pos.text = f"X: {mouse_x}\nY: {mouse_y}"
        mapping_result_dot_pos.setAutoDraw(True)
    
    # *mapping_result_end* updates
    if not keyboard_start and tThisFlip >= 0.0-frameTolerance:
        win.callOnFlip(mapping_result_end.clearEvents, eventType='keyboard')  # clear events on next screen flip
        keyboard_start = True
    if keyboard_start:
        theseKeys = mapping_result_end.getKeys(keyList=['space', 'd'], waitRelease=False)
        if len(theseKeys):
            theseKeys = theseKeys[0]  # at least one key was pressed
            if theseKeys == 'space':
                # a response ends the routine
                continueRoutine = False
            elif theseKeys == 'd':
                expInfo['Show_Raw_Data'] = not expInfo['Show_Raw_Data']
                test_complete_info.setAutoDraw(expInfo['Show_Raw_Data'])
                test_complete_dot_pos.setAutoDraw(expInfo['Show_Raw_Data'])
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    # refresh the screen
    elif continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Mapping_result"-------

for thisComponent in Mapping_result_autodraw:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# the Routine "Mapping_result" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

###################################################################################


###################################################################################

# Data output

expInfo['H_Clicks'] = ht_clicks
expInfo['V_Clicks'] = vt_clicks
expInfo['H_Points'] = ht_dots
expInfo['V_Points'] = vt_dots
expInfo['Raw_BS_Vertices'] = raw_vertices
expInfo['BS_Vertices'] = vertices
expInfo['BS_Center'] = bs_center
expInfo['HT_N'] = ht_N + 1
expInfo['H_Trials'] = ht_tests + hd_tests
expInfo['BS_width'], expInfo['BS_height'] = bs_width, bs_height
expInfo.update(staircaseInfo)
expInfo.update(validationInfo)
expInfo.update(eyetrackingInfo)
win.flip()

# these shouldn't be strictly necessary (should auto-save)
# thisExp.saveAsWideText(filename+'.csv')
# thisExp.saveAsPickle(filename)

exp_extraInfo = thisExp.extraInfo
with open(_thisDir + "/logconfig.json", "r") as f:
    data = json.load(f)

if expInfo['Staircase']:
    data += list(staircaseInfo.keys())
    try:
        staircase_data.to_json(filename + 'Staircase' + '.json', orient="split")
        staircase_data.to_csv(filename + 'Staircase' + '.csv')
    except Exception as e:
        print(e)

if expInfo['Validation'] != 'No':
    data += list(validationInfo.keys())
    try:
        visible_rate.to_json(filename + 'Validation' + '.json', orient = 'split')
        visible_rate.to_csv(filename + 'Validation' + '.csv')
    except Exception as e:
        print(e)
if expInfo['Eye_Tracker']:
    data += list(eyetrackingInfo.keys())
    try:
        HT_trials_tracking.to_csv(filename + 'HT_tracking' + '.csv')
        HT_trials_tracking.to_json(filename + 'HT_tracking' + '.json', orient = 'split')
        VT_trials_tracking.to_csv(filename + 'VT_tracking' + '.csv')
        VT_trials_tracking.to_json(filename + 'VT_tracking' + '.json', orient = 'split')
        HD_trials_tracking.to_csv(filename + 'HD_tracking' + '.csv')
        HD_trials_tracking.to_json(filename + 'HD_tracking' + '.json', orient = 'split')
        Staircase_tracking.to_csv(filename + 'Staircase_tracking' + '.csv')
        Staircase_tracking.to_json(filename + 'Staircase_tracking' + '.json', orient = 'split')
        Validation_tracking.to_csv(filename + 'Validation_tracking' + '.csv')
        Validation_tracking.to_json(filename + 'Validation_tracking' + '.json', orient = 'split')
    except Exception as e:
        print(e)

# save all raw data in a json file.
with open(filename + '.json', 'w') as txt_file:
    json.dump(exp_extraInfo, txt_file)
# raw data in a csv file
pd.DataFrame([exp_extraInfo]).to_csv(filename + '.csv', columns = data)

###################################################################################

# End experiment
logging.flush()

# make sure everything is closed down
if expInfo['Eye_Tracker']:
    tracker.setRecordingState(False)
    io.quit()
thisExp.abort()  # or data files will save again on exit
win.close()
core.quit()